# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases

if TYPE_CHECKING:
    from .client import Client
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UsersActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Users]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Users.prisma().query_raw(
            'SELECT * FROM Users WHERE id = $1',
            1103527590,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Users
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Users.prisma().query_first(
            'SELECT * FROM Users WHERE username = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UsersCreateInput,
        include: Optional[types.UsersInclude] = None
    ) -> _PrismaModelT:
        """Create a new Users record.

        Parameters
        ----------
        data
            Users record data
        include
            Specifies which relations should be loaded on the returned Users model

        Returns
        -------
        prisma.models.Users
            The created Users record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Users record from just the required fields
        users = await Users.prisma().create(
            data={
                # data to create a Users record
                'username': 'ggciceaie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UsersCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Users records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Users record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Users.prisma().create_many(
            data=[
                {
                    # data to create a Users record
                    'username': 'bbehjachib',
                },
                {
                    # data to create a Users record
                    'username': 'cadfabfehe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UsersWhereUniqueInput,
        include: Optional[types.UsersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Users record.

        Parameters
        ----------
        where
            Users filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Users model

        Returns
        -------
        prisma.models.Users
            The deleted Users record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await Users.prisma().delete(
            where={
                'id': 368800899,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.UsersWhereUniqueInput,
        include: Optional[types.UsersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Users record.

        Parameters
        ----------
        where
            Users filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Users model

        Returns
        -------
        prisma.models.Users
            The found Users record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await Users.prisma().find_unique(
            where={
                'id': 1508029952,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UsersWhereInput] = None,
        cursor: Optional[types.UsersWhereUniqueInput] = None,
        include: Optional[types.UsersInclude] = None,
        order: Optional[Union[types.UsersOrderByInput, List[types.UsersOrderByInput]]] = None,
        distinct: Optional[List[types.UsersScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Users records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Users records returned
        skip
            Ignore the first N results
        where
            Users filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Users model
        order
            Order the returned Users records by any field
        distinct
            Filter Users records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Users]
            The list of all Users records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Users records
        users = await Users.prisma().find_many(take=10)

        # find the first 5 Users records ordered by the created_at field
        users = await Users.prisma().find_many(
            take=5,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UsersWhereInput] = None,
        cursor: Optional[types.UsersWhereUniqueInput] = None,
        include: Optional[types.UsersInclude] = None,
        order: Optional[Union[types.UsersOrderByInput, List[types.UsersOrderByInput]]] = None,
        distinct: Optional[List[types.UsersScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Users record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Users filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Users model
        order
            Order the returned Users records by any field
        distinct
            Filter Users records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Users
            The first Users record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Users record ordered by the admin field
        users = await Users.prisma().find_first(
            skip=1,
            order={
                'admin': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.UsersUpdateInput,
        where: types.UsersWhereUniqueInput,
        include: Optional[types.UsersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Users record.

        Parameters
        ----------
        data
            Users record data specifying what to update
        where
            Users filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Users model

        Returns
        -------
        prisma.models.Users
            The updated Users record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Users.prisma().update(
            where={
                'id': 486256185,
            },
            data={
                # data to update the Users record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.UsersWhereUniqueInput,
        data: types.UsersUpsertInput,
        include: Optional[types.UsersInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Users filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Users model

        Returns
        -------
        prisma.models.Users
            The created or updated Users record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await Users.prisma().upsert(
            where={
                'id': 1062517886,
            },
            data={
                'create': {
                    'id': 1062517886,
                    'username': 'cadfabfehe',
                },
                'update': {
                    'username': 'cadfabfehe',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.UsersUpdateManyMutationInput,
        where: types.UsersWhereInput,
    ) -> int:
        """Update multiple Users records

        Parameters
        ----------
        data
            Users data to update the selected Users records to
        where
            Filter to select the Users records to update

        Returns
        -------
        int
            The total number of Users records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Users records
        total = await Users.prisma().update_many(
            data={
                'id': 267834847
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UsersWhereInput] = None,
        cursor: Optional[types.UsersWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Users records present in the database

        Parameters
        ----------
        select
            Select the Users fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Users filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UsersCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Users.prisma().count()

        # results: prisma.types.UsersCountAggregateOutput
        results = await Users.prisma().count(
            select={
                '_all': True,
                'username': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UsersCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UsersWhereInput] = None,
        cursor: Optional[types.UsersWhereUniqueInput] = None,
    ) -> types.UsersCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UsersCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UsersWhereInput] = None,
        cursor: Optional[types.UsersWhereUniqueInput] = None,
    ) -> Union[int, types.UsersCountAggregateOutput]:
        """Count the number of Users records present in the database

        Parameters
        ----------
        select
            Select the Users fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Users filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UsersCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Users.prisma().count()

        # results: prisma.types.UsersCountAggregateOutput
        results = await Users.prisma().count(
            select={
                '_all': True,
                'created_at': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UsersCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UsersWhereInput] = None
    ) -> int:
        """Delete multiple Users records.

        Parameters
        ----------
        where
            Optional Users filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Users records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Users records
        total = await Users.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UsersScalarFieldKeysT'],
        *,
        where: Optional['types.UsersWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UsersAvgAggregateInput'] = None,
        sum: Optional['types.UsersSumAggregateInput'] = None,
        min: Optional['types.UsersMinAggregateInput'] = None,
        max: Optional['types.UsersMaxAggregateInput'] = None,
        having: Optional['types.UsersScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UsersCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UsersScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.UsersScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.UsersGroupByOutput']:
        """Group Users records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Users fields to group records by
        where
            Users filter to select records
        take
            Limit the maximum number of Users records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UsersGroupByOutput]
            A list of dictionaries representing the Users record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Users records by admin values
        # and count how many records are in each group
        results = await Users.prisma().group_by(
            ['admin'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserLoginsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserLogins]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserLogins.prisma().query_raw(
            'SELECT * FROM UserLogins WHERE id = $1',
            180171308,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserLogins
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserLogins.prisma().query_first(
            'SELECT * FROM UserLogins WHERE password = $1',
            'idghgaicb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserLoginsCreateInput,
        include: Optional[types.UserLoginsInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserLogins record.

        Parameters
        ----------
        data
            UserLogins record data
        include
            Specifies which relations should be loaded on the returned UserLogins model

        Returns
        -------
        prisma.models.UserLogins
            The created UserLogins record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserLogins record from just the required fields
        userlogins = await UserLogins.prisma().create(
            data={
                # data to create a UserLogins record
                'id': 595337866,
                'password': 'hjaecfifb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserLoginsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserLogins records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserLogins record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserLogins.prisma().create_many(
            data=[
                {
                    # data to create a UserLogins record
                    'id': 2111915288,
                    'password': 'bbejhfidcb',
                },
                {
                    # data to create a UserLogins record
                    'id': 1644289366,
                    'password': 'bdiicjafbj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserLoginsWhereUniqueInput,
        include: Optional[types.UserLoginsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserLogins record.

        Parameters
        ----------
        where
            UserLogins filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserLogins model

        Returns
        -------
        prisma.models.UserLogins
            The deleted UserLogins record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userlogins = await UserLogins.prisma().delete(
            where={
                'id': 1647418052,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserLoginsWhereUniqueInput,
        include: Optional[types.UserLoginsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserLogins record.

        Parameters
        ----------
        where
            UserLogins filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserLogins model

        Returns
        -------
        prisma.models.UserLogins
            The found UserLogins record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userlogins = await UserLogins.prisma().find_unique(
            where={
                'id': 1675546029,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserLoginsWhereInput] = None,
        cursor: Optional[types.UserLoginsWhereUniqueInput] = None,
        include: Optional[types.UserLoginsInclude] = None,
        order: Optional[Union[types.UserLoginsOrderByInput, List[types.UserLoginsOrderByInput]]] = None,
        distinct: Optional[List[types.UserLoginsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserLogins records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserLogins records returned
        skip
            Ignore the first N results
        where
            UserLogins filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserLogins model
        order
            Order the returned UserLogins records by any field
        distinct
            Filter UserLogins records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserLogins]
            The list of all UserLogins records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserLogins records
        userlogins = await UserLogins.prisma().find_many(take=10)

        # find the first 5 UserLogins records ordered by the id field
        userlogins = await UserLogins.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserLoginsWhereInput] = None,
        cursor: Optional[types.UserLoginsWhereUniqueInput] = None,
        include: Optional[types.UserLoginsInclude] = None,
        order: Optional[Union[types.UserLoginsOrderByInput, List[types.UserLoginsOrderByInput]]] = None,
        distinct: Optional[List[types.UserLoginsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserLogins record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserLogins filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserLogins model
        order
            Order the returned UserLogins records by any field
        distinct
            Filter UserLogins records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserLogins
            The first UserLogins record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserLogins record ordered by the password field
        userlogins = await UserLogins.prisma().find_first(
            skip=1,
            order={
                'password': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.UserLoginsUpdateInput,
        where: types.UserLoginsWhereUniqueInput,
        include: Optional[types.UserLoginsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserLogins record.

        Parameters
        ----------
        data
            UserLogins record data specifying what to update
        where
            UserLogins filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserLogins model

        Returns
        -------
        prisma.models.UserLogins
            The updated UserLogins record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userlogins = await UserLogins.prisma().update(
            where={
                'id': 1767274722,
            },
            data={
                # data to update the UserLogins record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.UserLoginsWhereUniqueInput,
        data: types.UserLoginsUpsertInput,
        include: Optional[types.UserLoginsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserLogins filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserLogins model

        Returns
        -------
        prisma.models.UserLogins
            The created or updated UserLogins record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userlogins = await UserLogins.prisma().upsert(
            where={
                'id': 326272115,
            },
            data={
                'create': {
                    'id': 326272115,
                    'password': 'bdiicjafbj',
                },
                'update': {
                    'password': 'bdiicjafbj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.UserLoginsUpdateManyMutationInput,
        where: types.UserLoginsWhereInput,
    ) -> int:
        """Update multiple UserLogins records

        Parameters
        ----------
        data
            UserLogins data to update the selected UserLogins records to
        where
            Filter to select the UserLogins records to update

        Returns
        -------
        int
            The total number of UserLogins records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserLogins records
        total = await UserLogins.prisma().update_many(
            data={
                'id': 1343201072
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserLoginsWhereInput] = None,
        cursor: Optional[types.UserLoginsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserLogins records present in the database

        Parameters
        ----------
        select
            Select the UserLogins fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserLogins filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserLoginsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserLogins.prisma().count()

        # results: prisma.types.UserLoginsCountAggregateOutput
        results = await UserLogins.prisma().count(
            select={
                '_all': True,
                'password': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserLoginsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserLoginsWhereInput] = None,
        cursor: Optional[types.UserLoginsWhereUniqueInput] = None,
    ) -> types.UserLoginsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserLoginsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserLoginsWhereInput] = None,
        cursor: Optional[types.UserLoginsWhereUniqueInput] = None,
    ) -> Union[int, types.UserLoginsCountAggregateOutput]:
        """Count the number of UserLogins records present in the database

        Parameters
        ----------
        select
            Select the UserLogins fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserLogins filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserLoginsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserLogins.prisma().count()

        # results: prisma.types.UserLoginsCountAggregateOutput
        results = await UserLogins.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserLoginsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserLoginsWhereInput] = None
    ) -> int:
        """Delete multiple UserLogins records.

        Parameters
        ----------
        where
            Optional UserLogins filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserLogins records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserLogins records
        total = await UserLogins.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserLoginsScalarFieldKeysT'],
        *,
        where: Optional['types.UserLoginsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserLoginsAvgAggregateInput'] = None,
        sum: Optional['types.UserLoginsSumAggregateInput'] = None,
        min: Optional['types.UserLoginsMinAggregateInput'] = None,
        max: Optional['types.UserLoginsMaxAggregateInput'] = None,
        having: Optional['types.UserLoginsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserLoginsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserLoginsScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.UserLoginsScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.UserLoginsGroupByOutput']:
        """Group UserLogins records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserLogins fields to group records by
        where
            UserLogins filter to select records
        take
            Limit the maximum number of UserLogins records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserLoginsGroupByOutput]
            A list of dictionaries representing the UserLogins record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserLogins records by password values
        # and count how many records are in each group
        results = await UserLogins.prisma().group_by(
            ['password'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserCookiesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserCookies]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserCookies.prisma().query_raw(
            'SELECT * FROM UserCookies WHERE user_id = $1',
            675780521,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserCookies
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserCookies.prisma().query_first(
            'SELECT * FROM UserCookies WHERE cookie = $1',
            'heejgedji',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCookiesCreateInput,
        include: Optional[types.UserCookiesInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserCookies record.

        Parameters
        ----------
        data
            UserCookies record data
        include
            Specifies which relations should be loaded on the returned UserCookies model

        Returns
        -------
        prisma.models.UserCookies
            The created UserCookies record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserCookies record from just the required fields
        usercookies = await UserCookies.prisma().create(
            data={
                # data to create a UserCookies record
                'user_id': 1969681615,
                'cookie': 'bbbgbhfjge',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCookiesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserCookies records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserCookies record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserCookies.prisma().create_many(
            data=[
                {
                    # data to create a UserCookies record
                    'user_id': 861472101,
                    'cookie': 'bdadaadhag',
                },
                {
                    # data to create a UserCookies record
                    'user_id': 1686638315,
                    'cookie': 'caaaedabfc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserCookiesWhereUniqueInput,
        include: Optional[types.UserCookiesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserCookies record.

        Parameters
        ----------
        where
            UserCookies filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserCookies model

        Returns
        -------
        prisma.models.UserCookies
            The deleted UserCookies record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usercookies = await UserCookies.prisma().delete(
            where={
                'cookie': 'bigibebcib',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserCookiesWhereUniqueInput,
        include: Optional[types.UserCookiesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserCookies record.

        Parameters
        ----------
        where
            UserCookies filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserCookies model

        Returns
        -------
        prisma.models.UserCookies
            The found UserCookies record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usercookies = await UserCookies.prisma().find_unique(
            where={
                'cookie': 'bigaiehgcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserCookiesWhereInput] = None,
        cursor: Optional[types.UserCookiesWhereUniqueInput] = None,
        include: Optional[types.UserCookiesInclude] = None,
        order: Optional[Union[types.UserCookiesOrderByInput, List[types.UserCookiesOrderByInput]]] = None,
        distinct: Optional[List[types.UserCookiesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserCookies records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserCookies records returned
        skip
            Ignore the first N results
        where
            UserCookies filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserCookies model
        order
            Order the returned UserCookies records by any field
        distinct
            Filter UserCookies records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserCookies]
            The list of all UserCookies records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserCookies records
        usercookies = await UserCookies.prisma().find_many(take=10)

        # find the first 5 UserCookies records ordered by the user_id field
        usercookies = await UserCookies.prisma().find_many(
            take=5,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserCookiesWhereInput] = None,
        cursor: Optional[types.UserCookiesWhereUniqueInput] = None,
        include: Optional[types.UserCookiesInclude] = None,
        order: Optional[Union[types.UserCookiesOrderByInput, List[types.UserCookiesOrderByInput]]] = None,
        distinct: Optional[List[types.UserCookiesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserCookies record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserCookies filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserCookies model
        order
            Order the returned UserCookies records by any field
        distinct
            Filter UserCookies records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserCookies
            The first UserCookies record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserCookies record ordered by the cookie field
        usercookies = await UserCookies.prisma().find_first(
            skip=1,
            order={
                'cookie': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.UserCookiesUpdateInput,
        where: types.UserCookiesWhereUniqueInput,
        include: Optional[types.UserCookiesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserCookies record.

        Parameters
        ----------
        data
            UserCookies record data specifying what to update
        where
            UserCookies filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserCookies model

        Returns
        -------
        prisma.models.UserCookies
            The updated UserCookies record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        usercookies = await UserCookies.prisma().update(
            where={
                'cookie': 'beeifcbebf',
            },
            data={
                # data to update the UserCookies record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.UserCookiesWhereUniqueInput,
        data: types.UserCookiesUpsertInput,
        include: Optional[types.UserCookiesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserCookies filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserCookies model

        Returns
        -------
        prisma.models.UserCookies
            The created or updated UserCookies record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usercookies = await UserCookies.prisma().upsert(
            where={
                'cookie': 'bgcigfahea',
            },
            data={
                'create': {
                    'cookie': 'bgcigfahea',
                    'user_id': 1686638315,
                },
                'update': {
                    'user_id': 1686638315,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.UserCookiesUpdateManyMutationInput,
        where: types.UserCookiesWhereInput,
    ) -> int:
        """Update multiple UserCookies records

        Parameters
        ----------
        data
            UserCookies data to update the selected UserCookies records to
        where
            Filter to select the UserCookies records to update

        Returns
        -------
        int
            The total number of UserCookies records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserCookies records
        total = await UserCookies.prisma().update_many(
            data={
                'user_id': 1249606685
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserCookiesWhereInput] = None,
        cursor: Optional[types.UserCookiesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserCookies records present in the database

        Parameters
        ----------
        select
            Select the UserCookies fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserCookies filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCookiesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserCookies.prisma().count()

        # results: prisma.types.UserCookiesCountAggregateOutput
        results = await UserCookies.prisma().count(
            select={
                '_all': True,
                'cookie': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCookiesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserCookiesWhereInput] = None,
        cursor: Optional[types.UserCookiesWhereUniqueInput] = None,
    ) -> types.UserCookiesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCookiesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserCookiesWhereInput] = None,
        cursor: Optional[types.UserCookiesWhereUniqueInput] = None,
    ) -> Union[int, types.UserCookiesCountAggregateOutput]:
        """Count the number of UserCookies records present in the database

        Parameters
        ----------
        select
            Select the UserCookies fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserCookies filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCookiesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserCookies.prisma().count()

        # results: prisma.types.UserCookiesCountAggregateOutput
        results = await UserCookies.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCookiesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserCookiesWhereInput] = None
    ) -> int:
        """Delete multiple UserCookies records.

        Parameters
        ----------
        where
            Optional UserCookies filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserCookies records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserCookies records
        total = await UserCookies.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserCookiesScalarFieldKeysT'],
        *,
        where: Optional['types.UserCookiesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserCookiesAvgAggregateInput'] = None,
        sum: Optional['types.UserCookiesSumAggregateInput'] = None,
        min: Optional['types.UserCookiesMinAggregateInput'] = None,
        max: Optional['types.UserCookiesMaxAggregateInput'] = None,
        having: Optional['types.UserCookiesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCookiesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserCookiesScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.UserCookiesScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.UserCookiesGroupByOutput']:
        """Group UserCookies records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserCookies fields to group records by
        where
            UserCookies filter to select records
        take
            Limit the maximum number of UserCookies records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserCookiesGroupByOutput]
            A list of dictionaries representing the UserCookies record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserCookies records by cookie values
        # and count how many records are in each group
        results = await UserCookies.prisma().group_by(
            ['cookie'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class NewsSourcesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.NewsSources]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await NewsSources.prisma().query_raw(
            'SELECT * FROM NewsSources WHERE id = $1',
            835903122,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.NewsSources
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await NewsSources.prisma().query_first(
            'SELECT * FROM NewsSources WHERE name = $1',
            'hgdhbjhhj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.NewsSourcesCreateInput,
        include: Optional[types.NewsSourcesInclude] = None
    ) -> _PrismaModelT:
        """Create a new NewsSources record.

        Parameters
        ----------
        data
            NewsSources record data
        include
            Specifies which relations should be loaded on the returned NewsSources model

        Returns
        -------
        prisma.models.NewsSources
            The created NewsSources record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a NewsSources record from just the required fields
        newssources = await NewsSources.prisma().create(
            data={
                # data to create a NewsSources record
                'name': 'ecjjjfbae',
                'url': 'bhhfibbigf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.NewsSourcesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple NewsSources records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of NewsSources record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await NewsSources.prisma().create_many(
            data=[
                {
                    # data to create a NewsSources record
                    'name': 'ijdbeffgg',
                    'url': 'jjfeafhfj',
                },
                {
                    # data to create a NewsSources record
                    'name': 'cbachdgfce',
                    'url': 'chbfcacbd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.NewsSourcesWhereUniqueInput,
        include: Optional[types.NewsSourcesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single NewsSources record.

        Parameters
        ----------
        where
            NewsSources filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned NewsSources model

        Returns
        -------
        prisma.models.NewsSources
            The deleted NewsSources record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        newssources = await NewsSources.prisma().delete(
            where={
                'id': 456633834,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.NewsSourcesWhereUniqueInput,
        include: Optional[types.NewsSourcesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique NewsSources record.

        Parameters
        ----------
        where
            NewsSources filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned NewsSources model

        Returns
        -------
        prisma.models.NewsSources
            The found NewsSources record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        newssources = await NewsSources.prisma().find_unique(
            where={
                'id': 2058258651,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NewsSourcesWhereInput] = None,
        cursor: Optional[types.NewsSourcesWhereUniqueInput] = None,
        include: Optional[types.NewsSourcesInclude] = None,
        order: Optional[Union[types.NewsSourcesOrderByInput, List[types.NewsSourcesOrderByInput]]] = None,
        distinct: Optional[List[types.NewsSourcesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple NewsSources records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of NewsSources records returned
        skip
            Ignore the first N results
        where
            NewsSources filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned NewsSources model
        order
            Order the returned NewsSources records by any field
        distinct
            Filter NewsSources records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.NewsSources]
            The list of all NewsSources records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 NewsSources records
        newssources = await NewsSources.prisma().find_many(take=10)

        # find the first 5 NewsSources records ordered by the url field
        newssources = await NewsSources.prisma().find_many(
            take=5,
            order={
                'url': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NewsSourcesWhereInput] = None,
        cursor: Optional[types.NewsSourcesWhereUniqueInput] = None,
        include: Optional[types.NewsSourcesInclude] = None,
        order: Optional[Union[types.NewsSourcesOrderByInput, List[types.NewsSourcesOrderByInput]]] = None,
        distinct: Optional[List[types.NewsSourcesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single NewsSources record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            NewsSources filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned NewsSources model
        order
            Order the returned NewsSources records by any field
        distinct
            Filter NewsSources records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.NewsSources
            The first NewsSources record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second NewsSources record ordered by the id field
        newssources = await NewsSources.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.NewsSourcesUpdateInput,
        where: types.NewsSourcesWhereUniqueInput,
        include: Optional[types.NewsSourcesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single NewsSources record.

        Parameters
        ----------
        data
            NewsSources record data specifying what to update
        where
            NewsSources filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned NewsSources model

        Returns
        -------
        prisma.models.NewsSources
            The updated NewsSources record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        newssources = await NewsSources.prisma().update(
            where={
                'id': 1583689592,
            },
            data={
                # data to update the NewsSources record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.NewsSourcesWhereUniqueInput,
        data: types.NewsSourcesUpsertInput,
        include: Optional[types.NewsSourcesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            NewsSources filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned NewsSources model

        Returns
        -------
        prisma.models.NewsSources
            The created or updated NewsSources record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        newssources = await NewsSources.prisma().upsert(
            where={
                'id': 878442065,
            },
            data={
                'create': {
                    'id': 878442065,
                    'name': 'cbachdgfce',
                    'url': 'chbfcacbd',
                },
                'update': {
                    'name': 'cbachdgfce',
                    'url': 'chbfcacbd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.NewsSourcesUpdateManyMutationInput,
        where: types.NewsSourcesWhereInput,
    ) -> int:
        """Update multiple NewsSources records

        Parameters
        ----------
        data
            NewsSources data to update the selected NewsSources records to
        where
            Filter to select the NewsSources records to update

        Returns
        -------
        int
            The total number of NewsSources records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all NewsSources records
        total = await NewsSources.prisma().update_many(
            data={
                'name': 'bghfciaafe'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NewsSourcesWhereInput] = None,
        cursor: Optional[types.NewsSourcesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of NewsSources records present in the database

        Parameters
        ----------
        select
            Select the NewsSources fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            NewsSources filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NewsSourcesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await NewsSources.prisma().count()

        # results: prisma.types.NewsSourcesCountAggregateOutput
        results = await NewsSources.prisma().count(
            select={
                '_all': True,
                'url': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.NewsSourcesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NewsSourcesWhereInput] = None,
        cursor: Optional[types.NewsSourcesWhereUniqueInput] = None,
    ) -> types.NewsSourcesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.NewsSourcesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NewsSourcesWhereInput] = None,
        cursor: Optional[types.NewsSourcesWhereUniqueInput] = None,
    ) -> Union[int, types.NewsSourcesCountAggregateOutput]:
        """Count the number of NewsSources records present in the database

        Parameters
        ----------
        select
            Select the NewsSources fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            NewsSources filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NewsSourcesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await NewsSources.prisma().count()

        # results: prisma.types.NewsSourcesCountAggregateOutput
        results = await NewsSources.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.NewsSourcesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.NewsSourcesWhereInput] = None
    ) -> int:
        """Delete multiple NewsSources records.

        Parameters
        ----------
        where
            Optional NewsSources filter to find the records to be deleted

        Returns
        -------
        int
            The total number of NewsSources records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all NewsSources records
        total = await NewsSources.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.NewsSourcesScalarFieldKeysT'],
        *,
        where: Optional['types.NewsSourcesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.NewsSourcesAvgAggregateInput'] = None,
        sum: Optional['types.NewsSourcesSumAggregateInput'] = None,
        min: Optional['types.NewsSourcesMinAggregateInput'] = None,
        max: Optional['types.NewsSourcesMaxAggregateInput'] = None,
        having: Optional['types.NewsSourcesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.NewsSourcesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.NewsSourcesScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.NewsSourcesScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.NewsSourcesGroupByOutput']:
        """Group NewsSources records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar NewsSources fields to group records by
        where
            NewsSources filter to select records
        take
            Limit the maximum number of NewsSources records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.NewsSourcesGroupByOutput]
            A list of dictionaries representing the NewsSources record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group NewsSources records by name values
        # and count how many records are in each group
        results = await NewsSources.prisma().group_by(
            ['name'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class RssEntriesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.RssEntries]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await RssEntries.prisma().query_raw(
            'SELECT * FROM RssEntries WHERE source_id = $1',
            1627576247,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.RssEntries
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await RssEntries.prisma().query_first(
            'SELECT * FROM RssEntries WHERE feed = $1',
            'cafeiaccbc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.RssEntriesCreateInput,
        include: Optional[types.RssEntriesInclude] = None
    ) -> _PrismaModelT:
        """Create a new RssEntries record.

        Parameters
        ----------
        data
            RssEntries record data
        include
            Specifies which relations should be loaded on the returned RssEntries model

        Returns
        -------
        prisma.models.RssEntries
            The created RssEntries record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a RssEntries record from just the required fields
        rssentries = await RssEntries.prisma().create(
            data={
                # data to create a RssEntries record
                'source_id': 60335757,
                'feed': 'gieegcbeg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.RssEntriesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple RssEntries records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of RssEntries record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await RssEntries.prisma().create_many(
            data=[
                {
                    # data to create a RssEntries record
                    'source_id': 1625503827,
                    'feed': 'fcbichhci',
                },
                {
                    # data to create a RssEntries record
                    'source_id': 1266032265,
                    'feed': 'jdcfdcgc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.RssEntriesWhereUniqueInput,
        include: Optional[types.RssEntriesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single RssEntries record.

        Parameters
        ----------
        where
            RssEntries filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned RssEntries model

        Returns
        -------
        prisma.models.RssEntries
            The deleted RssEntries record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rssentries = await RssEntries.prisma().delete(
            where={
                'feed': 'cafdaehjid',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.RssEntriesWhereUniqueInput,
        include: Optional[types.RssEntriesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique RssEntries record.

        Parameters
        ----------
        where
            RssEntries filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RssEntries model

        Returns
        -------
        prisma.models.RssEntries
            The found RssEntries record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rssentries = await RssEntries.prisma().find_unique(
            where={
                'feed': 'gifdddbia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RssEntriesWhereInput] = None,
        cursor: Optional[types.RssEntriesWhereUniqueInput] = None,
        include: Optional[types.RssEntriesInclude] = None,
        order: Optional[Union[types.RssEntriesOrderByInput, List[types.RssEntriesOrderByInput]]] = None,
        distinct: Optional[List[types.RssEntriesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple RssEntries records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of RssEntries records returned
        skip
            Ignore the first N results
        where
            RssEntries filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RssEntries model
        order
            Order the returned RssEntries records by any field
        distinct
            Filter RssEntries records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.RssEntries]
            The list of all RssEntries records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 RssEntries records
        rssentries = await RssEntries.prisma().find_many(take=10)

        # find the first 5 RssEntries records ordered by the source_id field
        rssentries = await RssEntries.prisma().find_many(
            take=5,
            order={
                'source_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RssEntriesWhereInput] = None,
        cursor: Optional[types.RssEntriesWhereUniqueInput] = None,
        include: Optional[types.RssEntriesInclude] = None,
        order: Optional[Union[types.RssEntriesOrderByInput, List[types.RssEntriesOrderByInput]]] = None,
        distinct: Optional[List[types.RssEntriesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single RssEntries record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RssEntries filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RssEntries model
        order
            Order the returned RssEntries records by any field
        distinct
            Filter RssEntries records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RssEntries
            The first RssEntries record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RssEntries record ordered by the feed field
        rssentries = await RssEntries.prisma().find_first(
            skip=1,
            order={
                'feed': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.RssEntriesUpdateInput,
        where: types.RssEntriesWhereUniqueInput,
        include: Optional[types.RssEntriesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single RssEntries record.

        Parameters
        ----------
        data
            RssEntries record data specifying what to update
        where
            RssEntries filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned RssEntries model

        Returns
        -------
        prisma.models.RssEntries
            The updated RssEntries record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        rssentries = await RssEntries.prisma().update(
            where={
                'feed': 'bchehecef',
            },
            data={
                # data to update the RssEntries record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.RssEntriesWhereUniqueInput,
        data: types.RssEntriesUpsertInput,
        include: Optional[types.RssEntriesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            RssEntries filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned RssEntries model

        Returns
        -------
        prisma.models.RssEntries
            The created or updated RssEntries record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rssentries = await RssEntries.prisma().upsert(
            where={
                'feed': 'jeijcbhfe',
            },
            data={
                'create': {
                    'feed': 'jeijcbhfe',
                    'source_id': 1266032265,
                },
                'update': {
                    'source_id': 1266032265,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.RssEntriesUpdateManyMutationInput,
        where: types.RssEntriesWhereInput,
    ) -> int:
        """Update multiple RssEntries records

        Parameters
        ----------
        data
            RssEntries data to update the selected RssEntries records to
        where
            Filter to select the RssEntries records to update

        Returns
        -------
        int
            The total number of RssEntries records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all RssEntries records
        total = await RssEntries.prisma().update_many(
            data={
                'source_id': 1964990155
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RssEntriesWhereInput] = None,
        cursor: Optional[types.RssEntriesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of RssEntries records present in the database

        Parameters
        ----------
        select
            Select the RssEntries fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RssEntries filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RssEntriesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await RssEntries.prisma().count()

        # results: prisma.types.RssEntriesCountAggregateOutput
        results = await RssEntries.prisma().count(
            select={
                '_all': True,
                'feed': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.RssEntriesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RssEntriesWhereInput] = None,
        cursor: Optional[types.RssEntriesWhereUniqueInput] = None,
    ) -> types.RssEntriesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.RssEntriesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RssEntriesWhereInput] = None,
        cursor: Optional[types.RssEntriesWhereUniqueInput] = None,
    ) -> Union[int, types.RssEntriesCountAggregateOutput]:
        """Count the number of RssEntries records present in the database

        Parameters
        ----------
        select
            Select the RssEntries fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RssEntries filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RssEntriesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await RssEntries.prisma().count()

        # results: prisma.types.RssEntriesCountAggregateOutput
        results = await RssEntries.prisma().count(
            select={
                '_all': True,
                'source_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.RssEntriesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.RssEntriesWhereInput] = None
    ) -> int:
        """Delete multiple RssEntries records.

        Parameters
        ----------
        where
            Optional RssEntries filter to find the records to be deleted

        Returns
        -------
        int
            The total number of RssEntries records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all RssEntries records
        total = await RssEntries.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.RssEntriesScalarFieldKeysT'],
        *,
        where: Optional['types.RssEntriesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.RssEntriesAvgAggregateInput'] = None,
        sum: Optional['types.RssEntriesSumAggregateInput'] = None,
        min: Optional['types.RssEntriesMinAggregateInput'] = None,
        max: Optional['types.RssEntriesMaxAggregateInput'] = None,
        having: Optional['types.RssEntriesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.RssEntriesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.RssEntriesScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.RssEntriesScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.RssEntriesGroupByOutput']:
        """Group RssEntries records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar RssEntries fields to group records by
        where
            RssEntries filter to select records
        take
            Limit the maximum number of RssEntries records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.RssEntriesGroupByOutput]
            A list of dictionaries representing the RssEntries record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group RssEntries records by feed values
        # and count how many records are in each group
        results = await RssEntries.prisma().group_by(
            ['feed'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class NewsArticlesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.NewsArticles]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await NewsArticles.prisma().query_raw(
            'SELECT * FROM NewsArticles WHERE id = $1',
            1228891816,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.NewsArticles
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await NewsArticles.prisma().query_first(
            'SELECT * FROM NewsArticles WHERE source_id = $1',
            255202753,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.NewsArticlesCreateInput,
        include: Optional[types.NewsArticlesInclude] = None
    ) -> _PrismaModelT:
        """Create a new NewsArticles record.

        Parameters
        ----------
        data
            NewsArticles record data
        include
            Specifies which relations should be loaded on the returned NewsArticles model

        Returns
        -------
        prisma.models.NewsArticles
            The created NewsArticles record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a NewsArticles record from just the required fields
        newsarticles = await NewsArticles.prisma().create(
            data={
                # data to create a NewsArticles record
                'source_id': 1223573862,
                'url': 'febcgjbfj',
                'title': 'bageiegghg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.NewsArticlesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple NewsArticles records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of NewsArticles record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await NewsArticles.prisma().create_many(
            data=[
                {
                    # data to create a NewsArticles record
                    'source_id': 508382461,
                    'url': 'bacecgfhbe',
                    'title': 'ihcahiead',
                },
                {
                    # data to create a NewsArticles record
                    'source_id': 1874748096,
                    'url': 'jbgijghgb',
                    'title': 'hgjcghfbi',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.NewsArticlesWhereUniqueInput,
        include: Optional[types.NewsArticlesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single NewsArticles record.

        Parameters
        ----------
        where
            NewsArticles filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned NewsArticles model

        Returns
        -------
        prisma.models.NewsArticles
            The deleted NewsArticles record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        newsarticles = await NewsArticles.prisma().delete(
            where={
                'id': 820312479,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.NewsArticlesWhereUniqueInput,
        include: Optional[types.NewsArticlesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique NewsArticles record.

        Parameters
        ----------
        where
            NewsArticles filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned NewsArticles model

        Returns
        -------
        prisma.models.NewsArticles
            The found NewsArticles record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        newsarticles = await NewsArticles.prisma().find_unique(
            where={
                'id': 92728044,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NewsArticlesWhereInput] = None,
        cursor: Optional[types.NewsArticlesWhereUniqueInput] = None,
        include: Optional[types.NewsArticlesInclude] = None,
        order: Optional[Union[types.NewsArticlesOrderByInput, List[types.NewsArticlesOrderByInput]]] = None,
        distinct: Optional[List[types.NewsArticlesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple NewsArticles records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of NewsArticles records returned
        skip
            Ignore the first N results
        where
            NewsArticles filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned NewsArticles model
        order
            Order the returned NewsArticles records by any field
        distinct
            Filter NewsArticles records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.NewsArticles]
            The list of all NewsArticles records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 NewsArticles records
        newsarticles = await NewsArticles.prisma().find_many(take=10)

        # find the first 5 NewsArticles records ordered by the url field
        newsarticles = await NewsArticles.prisma().find_many(
            take=5,
            order={
                'url': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NewsArticlesWhereInput] = None,
        cursor: Optional[types.NewsArticlesWhereUniqueInput] = None,
        include: Optional[types.NewsArticlesInclude] = None,
        order: Optional[Union[types.NewsArticlesOrderByInput, List[types.NewsArticlesOrderByInput]]] = None,
        distinct: Optional[List[types.NewsArticlesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single NewsArticles record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            NewsArticles filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned NewsArticles model
        order
            Order the returned NewsArticles records by any field
        distinct
            Filter NewsArticles records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.NewsArticles
            The first NewsArticles record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second NewsArticles record ordered by the title field
        newsarticles = await NewsArticles.prisma().find_first(
            skip=1,
            order={
                'title': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.NewsArticlesUpdateInput,
        where: types.NewsArticlesWhereUniqueInput,
        include: Optional[types.NewsArticlesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single NewsArticles record.

        Parameters
        ----------
        data
            NewsArticles record data specifying what to update
        where
            NewsArticles filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned NewsArticles model

        Returns
        -------
        prisma.models.NewsArticles
            The updated NewsArticles record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        newsarticles = await NewsArticles.prisma().update(
            where={
                'id': 344858293,
            },
            data={
                # data to update the NewsArticles record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.NewsArticlesWhereUniqueInput,
        data: types.NewsArticlesUpsertInput,
        include: Optional[types.NewsArticlesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            NewsArticles filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned NewsArticles model

        Returns
        -------
        prisma.models.NewsArticles
            The created or updated NewsArticles record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        newsarticles = await NewsArticles.prisma().upsert(
            where={
                'id': 1121741130,
            },
            data={
                'create': {
                    'id': 1121741130,
                    'source_id': 1874748096,
                    'url': 'jbgijghgb',
                    'title': 'hgjcghfbi',
                },
                'update': {
                    'source_id': 1874748096,
                    'url': 'jbgijghgb',
                    'title': 'hgjcghfbi',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.NewsArticlesUpdateManyMutationInput,
        where: types.NewsArticlesWhereInput,
    ) -> int:
        """Update multiple NewsArticles records

        Parameters
        ----------
        data
            NewsArticles data to update the selected NewsArticles records to
        where
            Filter to select the NewsArticles records to update

        Returns
        -------
        int
            The total number of NewsArticles records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all NewsArticles records
        total = await NewsArticles.prisma().update_many(
            data={
                'description': 'bejfijgcfb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NewsArticlesWhereInput] = None,
        cursor: Optional[types.NewsArticlesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of NewsArticles records present in the database

        Parameters
        ----------
        select
            Select the NewsArticles fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            NewsArticles filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NewsArticlesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await NewsArticles.prisma().count()

        # results: prisma.types.NewsArticlesCountAggregateOutput
        results = await NewsArticles.prisma().count(
            select={
                '_all': True,
                'photo': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.NewsArticlesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NewsArticlesWhereInput] = None,
        cursor: Optional[types.NewsArticlesWhereUniqueInput] = None,
    ) -> types.NewsArticlesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.NewsArticlesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NewsArticlesWhereInput] = None,
        cursor: Optional[types.NewsArticlesWhereUniqueInput] = None,
    ) -> Union[int, types.NewsArticlesCountAggregateOutput]:
        """Count the number of NewsArticles records present in the database

        Parameters
        ----------
        select
            Select the NewsArticles fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            NewsArticles filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NewsArticlesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await NewsArticles.prisma().count()

        # results: prisma.types.NewsArticlesCountAggregateOutput
        results = await NewsArticles.prisma().count(
            select={
                '_all': True,
                'publication_date': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.NewsArticlesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.NewsArticlesWhereInput] = None
    ) -> int:
        """Delete multiple NewsArticles records.

        Parameters
        ----------
        where
            Optional NewsArticles filter to find the records to be deleted

        Returns
        -------
        int
            The total number of NewsArticles records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all NewsArticles records
        total = await NewsArticles.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.NewsArticlesScalarFieldKeysT'],
        *,
        where: Optional['types.NewsArticlesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.NewsArticlesAvgAggregateInput'] = None,
        sum: Optional['types.NewsArticlesSumAggregateInput'] = None,
        min: Optional['types.NewsArticlesMinAggregateInput'] = None,
        max: Optional['types.NewsArticlesMaxAggregateInput'] = None,
        having: Optional['types.NewsArticlesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.NewsArticlesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.NewsArticlesScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.NewsArticlesScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.NewsArticlesGroupByOutput']:
        """Group NewsArticles records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar NewsArticles fields to group records by
        where
            NewsArticles filter to select records
        take
            Limit the maximum number of NewsArticles records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.NewsArticlesGroupByOutput]
            A list of dictionaries representing the NewsArticles record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group NewsArticles records by id values
        # and count how many records are in each group
        results = await NewsArticles.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SimilarArticlesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.SimilarArticles]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await SimilarArticles.prisma().query_raw(
            'SELECT * FROM SimilarArticles WHERE id1 = $1',
            208521688,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.SimilarArticles
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await SimilarArticles.prisma().query_first(
            'SELECT * FROM SimilarArticles WHERE id2 = $1',
            860811569,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SimilarArticlesCreateInput,
        include: Optional[types.SimilarArticlesInclude] = None
    ) -> _PrismaModelT:
        """Create a new SimilarArticles record.

        Parameters
        ----------
        data
            SimilarArticles record data
        include
            Specifies which relations should be loaded on the returned SimilarArticles model

        Returns
        -------
        prisma.models.SimilarArticles
            The created SimilarArticles record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a SimilarArticles record from just the required fields
        similararticles = await SimilarArticles.prisma().create(
            data={
                # data to create a SimilarArticles record
                'id1': 1660932118,
                'id2': 525761943,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SimilarArticlesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple SimilarArticles records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of SimilarArticles record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await SimilarArticles.prisma().create_many(
            data=[
                {
                    # data to create a SimilarArticles record
                    'id1': 736209796,
                    'id2': 493907821,
                },
                {
                    # data to create a SimilarArticles record
                    'id1': 639686562,
                    'id2': 654007347,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SimilarArticlesWhereUniqueInput,
        include: Optional[types.SimilarArticlesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single SimilarArticles record.

        Parameters
        ----------
        where
            SimilarArticles filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned SimilarArticles model

        Returns
        -------
        prisma.models.SimilarArticles
            The deleted SimilarArticles record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        similararticles = await SimilarArticles.prisma().delete(
            where={
                # SimilarArticles where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.SimilarArticlesWhereUniqueInput,
        include: Optional[types.SimilarArticlesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique SimilarArticles record.

        Parameters
        ----------
        where
            SimilarArticles filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SimilarArticles model

        Returns
        -------
        prisma.models.SimilarArticles
            The found SimilarArticles record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        similararticles = await SimilarArticles.prisma().find_unique(
            where={
                # SimilarArticles where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SimilarArticlesWhereInput] = None,
        cursor: Optional[types.SimilarArticlesWhereUniqueInput] = None,
        include: Optional[types.SimilarArticlesInclude] = None,
        order: Optional[Union[types.SimilarArticlesOrderByInput, List[types.SimilarArticlesOrderByInput]]] = None,
        distinct: Optional[List[types.SimilarArticlesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple SimilarArticles records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of SimilarArticles records returned
        skip
            Ignore the first N results
        where
            SimilarArticles filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SimilarArticles model
        order
            Order the returned SimilarArticles records by any field
        distinct
            Filter SimilarArticles records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.SimilarArticles]
            The list of all SimilarArticles records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 SimilarArticles records
        similararticles = await SimilarArticles.prisma().find_many(take=10)

        # find the first 5 SimilarArticles records ordered by the id1 field
        similararticles = await SimilarArticles.prisma().find_many(
            take=5,
            order={
                'id1': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SimilarArticlesWhereInput] = None,
        cursor: Optional[types.SimilarArticlesWhereUniqueInput] = None,
        include: Optional[types.SimilarArticlesInclude] = None,
        order: Optional[Union[types.SimilarArticlesOrderByInput, List[types.SimilarArticlesOrderByInput]]] = None,
        distinct: Optional[List[types.SimilarArticlesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single SimilarArticles record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SimilarArticles filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SimilarArticles model
        order
            Order the returned SimilarArticles records by any field
        distinct
            Filter SimilarArticles records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SimilarArticles
            The first SimilarArticles record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SimilarArticles record ordered by the id2 field
        similararticles = await SimilarArticles.prisma().find_first(
            skip=1,
            order={
                'id2': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.SimilarArticlesUpdateInput,
        where: types.SimilarArticlesWhereUniqueInput,
        include: Optional[types.SimilarArticlesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single SimilarArticles record.

        Parameters
        ----------
        data
            SimilarArticles record data specifying what to update
        where
            SimilarArticles filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned SimilarArticles model

        Returns
        -------
        prisma.models.SimilarArticles
            The updated SimilarArticles record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        similararticles = await SimilarArticles.prisma().update(
            where={
                # SimilarArticles where unique filter

            },
            data={
                # data to update the SimilarArticles record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.SimilarArticlesWhereUniqueInput,
        data: types.SimilarArticlesUpsertInput,
        include: Optional[types.SimilarArticlesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            SimilarArticles filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned SimilarArticles model

        Returns
        -------
        prisma.models.SimilarArticles
            The created or updated SimilarArticles record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        similararticles = await SimilarArticles.prisma().upsert(
            where={
                # SimilarArticles where unique filter
            },
            data={
                'create': {
                    # SimilarArticles data to be set if the record does not exist
                },
                'update': {
                    # SimilarArticles data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.SimilarArticlesUpdateManyMutationInput,
        where: types.SimilarArticlesWhereInput,
    ) -> int:
        """Update multiple SimilarArticles records

        Parameters
        ----------
        data
            SimilarArticles data to update the selected SimilarArticles records to
        where
            Filter to select the SimilarArticles records to update

        Returns
        -------
        int
            The total number of SimilarArticles records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all SimilarArticles records
        total = await SimilarArticles.prisma().update_many(
            data={
                'id1': 1905261552
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SimilarArticlesWhereInput] = None,
        cursor: Optional[types.SimilarArticlesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of SimilarArticles records present in the database

        Parameters
        ----------
        select
            Select the SimilarArticles fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SimilarArticles filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SimilarArticlesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SimilarArticles.prisma().count()

        # results: prisma.types.SimilarArticlesCountAggregateOutput
        results = await SimilarArticles.prisma().count(
            select={
                '_all': True,
                'id2': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SimilarArticlesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SimilarArticlesWhereInput] = None,
        cursor: Optional[types.SimilarArticlesWhereUniqueInput] = None,
    ) -> types.SimilarArticlesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SimilarArticlesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SimilarArticlesWhereInput] = None,
        cursor: Optional[types.SimilarArticlesWhereUniqueInput] = None,
    ) -> Union[int, types.SimilarArticlesCountAggregateOutput]:
        """Count the number of SimilarArticles records present in the database

        Parameters
        ----------
        select
            Select the SimilarArticles fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SimilarArticles filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SimilarArticlesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SimilarArticles.prisma().count()

        # results: prisma.types.SimilarArticlesCountAggregateOutput
        results = await SimilarArticles.prisma().count(
            select={
                '_all': True,
                'id1': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SimilarArticlesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SimilarArticlesWhereInput] = None
    ) -> int:
        """Delete multiple SimilarArticles records.

        Parameters
        ----------
        where
            Optional SimilarArticles filter to find the records to be deleted

        Returns
        -------
        int
            The total number of SimilarArticles records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all SimilarArticles records
        total = await SimilarArticles.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SimilarArticlesScalarFieldKeysT'],
        *,
        where: Optional['types.SimilarArticlesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SimilarArticlesAvgAggregateInput'] = None,
        sum: Optional['types.SimilarArticlesSumAggregateInput'] = None,
        min: Optional['types.SimilarArticlesMinAggregateInput'] = None,
        max: Optional['types.SimilarArticlesMaxAggregateInput'] = None,
        having: Optional['types.SimilarArticlesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SimilarArticlesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SimilarArticlesScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.SimilarArticlesScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.SimilarArticlesGroupByOutput']:
        """Group SimilarArticles records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar SimilarArticles fields to group records by
        where
            SimilarArticles filter to select records
        take
            Limit the maximum number of SimilarArticles records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SimilarArticlesGroupByOutput]
            A list of dictionaries representing the SimilarArticles record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group SimilarArticles records by id2 values
        # and count how many records are in each group
        results = await SimilarArticles.prisma().group_by(
            ['id2'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class NewsArticleLabelsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.NewsArticleLabels]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await NewsArticleLabels.prisma().query_raw(
            'SELECT * FROM NewsArticleLabels WHERE id = $1',
            78746985,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.NewsArticleLabels
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await NewsArticleLabels.prisma().query_first(
            'SELECT * FROM NewsArticleLabels WHERE label = $1',
            'bdjidcidac',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.NewsArticleLabelsCreateInput,
        include: Optional[types.NewsArticleLabelsInclude] = None
    ) -> _PrismaModelT:
        """Create a new NewsArticleLabels record.

        Parameters
        ----------
        data
            NewsArticleLabels record data
        include
            Specifies which relations should be loaded on the returned NewsArticleLabels model

        Returns
        -------
        prisma.models.NewsArticleLabels
            The created NewsArticleLabels record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a NewsArticleLabels record from just the required fields
        newsarticlelabels = await NewsArticleLabels.prisma().create(
            data={
                # data to create a NewsArticleLabels record
                'id': 856000655,
                'label': 'befcddgjce',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.NewsArticleLabelsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple NewsArticleLabels records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of NewsArticleLabels record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await NewsArticleLabels.prisma().create_many(
            data=[
                {
                    # data to create a NewsArticleLabels record
                    'id': 1573199653,
                    'label': 'cabdjadaji',
                },
                {
                    # data to create a NewsArticleLabels record
                    'id': 500965035,
                    'label': 'biaagcedjc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.NewsArticleLabelsWhereUniqueInput,
        include: Optional[types.NewsArticleLabelsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single NewsArticleLabels record.

        Parameters
        ----------
        where
            NewsArticleLabels filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned NewsArticleLabels model

        Returns
        -------
        prisma.models.NewsArticleLabels
            The deleted NewsArticleLabels record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        newsarticlelabels = await NewsArticleLabels.prisma().delete(
            where={
                # NewsArticleLabels where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.NewsArticleLabelsWhereUniqueInput,
        include: Optional[types.NewsArticleLabelsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique NewsArticleLabels record.

        Parameters
        ----------
        where
            NewsArticleLabels filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned NewsArticleLabels model

        Returns
        -------
        prisma.models.NewsArticleLabels
            The found NewsArticleLabels record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        newsarticlelabels = await NewsArticleLabels.prisma().find_unique(
            where={
                # NewsArticleLabels where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NewsArticleLabelsWhereInput] = None,
        cursor: Optional[types.NewsArticleLabelsWhereUniqueInput] = None,
        include: Optional[types.NewsArticleLabelsInclude] = None,
        order: Optional[Union[types.NewsArticleLabelsOrderByInput, List[types.NewsArticleLabelsOrderByInput]]] = None,
        distinct: Optional[List[types.NewsArticleLabelsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple NewsArticleLabels records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of NewsArticleLabels records returned
        skip
            Ignore the first N results
        where
            NewsArticleLabels filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned NewsArticleLabels model
        order
            Order the returned NewsArticleLabels records by any field
        distinct
            Filter NewsArticleLabels records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.NewsArticleLabels]
            The list of all NewsArticleLabels records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 NewsArticleLabels records
        newsarticlelabels = await NewsArticleLabels.prisma().find_many(take=10)

        # find the first 5 NewsArticleLabels records ordered by the id field
        newsarticlelabels = await NewsArticleLabels.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NewsArticleLabelsWhereInput] = None,
        cursor: Optional[types.NewsArticleLabelsWhereUniqueInput] = None,
        include: Optional[types.NewsArticleLabelsInclude] = None,
        order: Optional[Union[types.NewsArticleLabelsOrderByInput, List[types.NewsArticleLabelsOrderByInput]]] = None,
        distinct: Optional[List[types.NewsArticleLabelsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single NewsArticleLabels record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            NewsArticleLabels filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned NewsArticleLabels model
        order
            Order the returned NewsArticleLabels records by any field
        distinct
            Filter NewsArticleLabels records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.NewsArticleLabels
            The first NewsArticleLabels record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second NewsArticleLabels record ordered by the label field
        newsarticlelabels = await NewsArticleLabels.prisma().find_first(
            skip=1,
            order={
                'label': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.NewsArticleLabelsUpdateInput,
        where: types.NewsArticleLabelsWhereUniqueInput,
        include: Optional[types.NewsArticleLabelsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single NewsArticleLabels record.

        Parameters
        ----------
        data
            NewsArticleLabels record data specifying what to update
        where
            NewsArticleLabels filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned NewsArticleLabels model

        Returns
        -------
        prisma.models.NewsArticleLabels
            The updated NewsArticleLabels record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        newsarticlelabels = await NewsArticleLabels.prisma().update(
            where={
                # NewsArticleLabels where unique filter

            },
            data={
                # data to update the NewsArticleLabels record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.NewsArticleLabelsWhereUniqueInput,
        data: types.NewsArticleLabelsUpsertInput,
        include: Optional[types.NewsArticleLabelsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            NewsArticleLabels filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned NewsArticleLabels model

        Returns
        -------
        prisma.models.NewsArticleLabels
            The created or updated NewsArticleLabels record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        newsarticlelabels = await NewsArticleLabels.prisma().upsert(
            where={
                # NewsArticleLabels where unique filter
            },
            data={
                'create': {
                    # NewsArticleLabels data to be set if the record does not exist
                },
                'update': {
                    # NewsArticleLabels data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.NewsArticleLabelsUpdateManyMutationInput,
        where: types.NewsArticleLabelsWhereInput,
    ) -> int:
        """Update multiple NewsArticleLabels records

        Parameters
        ----------
        data
            NewsArticleLabels data to update the selected NewsArticleLabels records to
        where
            Filter to select the NewsArticleLabels records to update

        Returns
        -------
        int
            The total number of NewsArticleLabels records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all NewsArticleLabels records
        total = await NewsArticleLabels.prisma().update_many(
            data={
                'id': 2077067425
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NewsArticleLabelsWhereInput] = None,
        cursor: Optional[types.NewsArticleLabelsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of NewsArticleLabels records present in the database

        Parameters
        ----------
        select
            Select the NewsArticleLabels fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            NewsArticleLabels filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NewsArticleLabelsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await NewsArticleLabels.prisma().count()

        # results: prisma.types.NewsArticleLabelsCountAggregateOutput
        results = await NewsArticleLabels.prisma().count(
            select={
                '_all': True,
                'label': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.NewsArticleLabelsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NewsArticleLabelsWhereInput] = None,
        cursor: Optional[types.NewsArticleLabelsWhereUniqueInput] = None,
    ) -> types.NewsArticleLabelsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.NewsArticleLabelsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NewsArticleLabelsWhereInput] = None,
        cursor: Optional[types.NewsArticleLabelsWhereUniqueInput] = None,
    ) -> Union[int, types.NewsArticleLabelsCountAggregateOutput]:
        """Count the number of NewsArticleLabels records present in the database

        Parameters
        ----------
        select
            Select the NewsArticleLabels fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            NewsArticleLabels filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NewsArticleLabelsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await NewsArticleLabels.prisma().count()

        # results: prisma.types.NewsArticleLabelsCountAggregateOutput
        results = await NewsArticleLabels.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.NewsArticleLabelsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.NewsArticleLabelsWhereInput] = None
    ) -> int:
        """Delete multiple NewsArticleLabels records.

        Parameters
        ----------
        where
            Optional NewsArticleLabels filter to find the records to be deleted

        Returns
        -------
        int
            The total number of NewsArticleLabels records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all NewsArticleLabels records
        total = await NewsArticleLabels.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.NewsArticleLabelsScalarFieldKeysT'],
        *,
        where: Optional['types.NewsArticleLabelsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.NewsArticleLabelsAvgAggregateInput'] = None,
        sum: Optional['types.NewsArticleLabelsSumAggregateInput'] = None,
        min: Optional['types.NewsArticleLabelsMinAggregateInput'] = None,
        max: Optional['types.NewsArticleLabelsMaxAggregateInput'] = None,
        having: Optional['types.NewsArticleLabelsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.NewsArticleLabelsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.NewsArticleLabelsScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.NewsArticleLabelsScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.NewsArticleLabelsGroupByOutput']:
        """Group NewsArticleLabels records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar NewsArticleLabels fields to group records by
        where
            NewsArticleLabels filter to select records
        take
            Limit the maximum number of NewsArticleLabels records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.NewsArticleLabelsGroupByOutput]
            A list of dictionaries representing the NewsArticleLabels record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group NewsArticleLabels records by label values
        # and count how many records are in each group
        results = await NewsArticleLabels.prisma().group_by(
            ['label'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UsersArticlesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UsersArticles]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UsersArticles.prisma().query_raw(
            'SELECT * FROM UsersArticles WHERE article_id = $1',
            1672112838,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UsersArticles
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UsersArticles.prisma().query_first(
            'SELECT * FROM UsersArticles WHERE source_id = $1',
            926677639,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UsersArticlesCreateInput,
        include: Optional[types.UsersArticlesInclude] = None
    ) -> _PrismaModelT:
        """Create a new UsersArticles record.

        Parameters
        ----------
        data
            UsersArticles record data
        include
            Specifies which relations should be loaded on the returned UsersArticles model

        Returns
        -------
        prisma.models.UsersArticles
            The created UsersArticles record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UsersArticles record from just the required fields
        usersarticles = await UsersArticles.prisma().create(
            data={
                # data to create a UsersArticles record
                'article_id': 1447624116,
                'source_id': 1738083805,
                'url': 'deajegcfi',
                'user_id': 601077795,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UsersArticlesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UsersArticles records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UsersArticles record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UsersArticles.prisma().create_many(
            data=[
                {
                    # data to create a UsersArticles record
                    'article_id': 290603296,
                    'source_id': 1855826649,
                    'url': 'bgbbaajbic',
                    'user_id': 446673791,
                },
                {
                    # data to create a UsersArticles record
                    'article_id': 300568396,
                    'source_id': 632626069,
                    'url': 'bhceabbgja',
                    'user_id': 470157467,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UsersArticlesWhereUniqueInput,
        include: Optional[types.UsersArticlesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UsersArticles record.

        Parameters
        ----------
        where
            UsersArticles filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UsersArticles model

        Returns
        -------
        prisma.models.UsersArticles
            The deleted UsersArticles record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersarticles = await UsersArticles.prisma().delete(
            where={
                # UsersArticles where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.UsersArticlesWhereUniqueInput,
        include: Optional[types.UsersArticlesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UsersArticles record.

        Parameters
        ----------
        where
            UsersArticles filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UsersArticles model

        Returns
        -------
        prisma.models.UsersArticles
            The found UsersArticles record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersarticles = await UsersArticles.prisma().find_unique(
            where={
                # UsersArticles where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UsersArticlesWhereInput] = None,
        cursor: Optional[types.UsersArticlesWhereUniqueInput] = None,
        include: Optional[types.UsersArticlesInclude] = None,
        order: Optional[Union[types.UsersArticlesOrderByInput, List[types.UsersArticlesOrderByInput]]] = None,
        distinct: Optional[List[types.UsersArticlesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UsersArticles records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UsersArticles records returned
        skip
            Ignore the first N results
        where
            UsersArticles filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UsersArticles model
        order
            Order the returned UsersArticles records by any field
        distinct
            Filter UsersArticles records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UsersArticles]
            The list of all UsersArticles records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UsersArticles records
        usersarticles = await UsersArticles.prisma().find_many(take=10)

        # find the first 5 UsersArticles records ordered by the url field
        usersarticles = await UsersArticles.prisma().find_many(
            take=5,
            order={
                'url': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UsersArticlesWhereInput] = None,
        cursor: Optional[types.UsersArticlesWhereUniqueInput] = None,
        include: Optional[types.UsersArticlesInclude] = None,
        order: Optional[Union[types.UsersArticlesOrderByInput, List[types.UsersArticlesOrderByInput]]] = None,
        distinct: Optional[List[types.UsersArticlesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UsersArticles record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UsersArticles filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UsersArticles model
        order
            Order the returned UsersArticles records by any field
        distinct
            Filter UsersArticles records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UsersArticles
            The first UsersArticles record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UsersArticles record ordered by the user_id field
        usersarticles = await UsersArticles.prisma().find_first(
            skip=1,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.UsersArticlesUpdateInput,
        where: types.UsersArticlesWhereUniqueInput,
        include: Optional[types.UsersArticlesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UsersArticles record.

        Parameters
        ----------
        data
            UsersArticles record data specifying what to update
        where
            UsersArticles filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UsersArticles model

        Returns
        -------
        prisma.models.UsersArticles
            The updated UsersArticles record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        usersarticles = await UsersArticles.prisma().update(
            where={
                # UsersArticles where unique filter

            },
            data={
                # data to update the UsersArticles record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.UsersArticlesWhereUniqueInput,
        data: types.UsersArticlesUpsertInput,
        include: Optional[types.UsersArticlesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UsersArticles filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UsersArticles model

        Returns
        -------
        prisma.models.UsersArticles
            The created or updated UsersArticles record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersarticles = await UsersArticles.prisma().upsert(
            where={
                # UsersArticles where unique filter
            },
            data={
                'create': {
                    # UsersArticles data to be set if the record does not exist
                },
                'update': {
                    # UsersArticles data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.UsersArticlesUpdateManyMutationInput,
        where: types.UsersArticlesWhereInput,
    ) -> int:
        """Update multiple UsersArticles records

        Parameters
        ----------
        data
            UsersArticles data to update the selected UsersArticles records to
        where
            Filter to select the UsersArticles records to update

        Returns
        -------
        int
            The total number of UsersArticles records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UsersArticles records
        total = await UsersArticles.prisma().update_many(
            data={
                'article_id': 1209209912
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UsersArticlesWhereInput] = None,
        cursor: Optional[types.UsersArticlesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UsersArticles records present in the database

        Parameters
        ----------
        select
            Select the UsersArticles fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UsersArticles filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UsersArticlesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UsersArticles.prisma().count()

        # results: prisma.types.UsersArticlesCountAggregateOutput
        results = await UsersArticles.prisma().count(
            select={
                '_all': True,
                'source_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UsersArticlesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UsersArticlesWhereInput] = None,
        cursor: Optional[types.UsersArticlesWhereUniqueInput] = None,
    ) -> types.UsersArticlesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UsersArticlesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UsersArticlesWhereInput] = None,
        cursor: Optional[types.UsersArticlesWhereUniqueInput] = None,
    ) -> Union[int, types.UsersArticlesCountAggregateOutput]:
        """Count the number of UsersArticles records present in the database

        Parameters
        ----------
        select
            Select the UsersArticles fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UsersArticles filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UsersArticlesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UsersArticles.prisma().count()

        # results: prisma.types.UsersArticlesCountAggregateOutput
        results = await UsersArticles.prisma().count(
            select={
                '_all': True,
                'url': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UsersArticlesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UsersArticlesWhereInput] = None
    ) -> int:
        """Delete multiple UsersArticles records.

        Parameters
        ----------
        where
            Optional UsersArticles filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UsersArticles records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UsersArticles records
        total = await UsersArticles.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UsersArticlesScalarFieldKeysT'],
        *,
        where: Optional['types.UsersArticlesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UsersArticlesAvgAggregateInput'] = None,
        sum: Optional['types.UsersArticlesSumAggregateInput'] = None,
        min: Optional['types.UsersArticlesMinAggregateInput'] = None,
        max: Optional['types.UsersArticlesMaxAggregateInput'] = None,
        having: Optional['types.UsersArticlesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UsersArticlesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UsersArticlesScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.UsersArticlesScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.UsersArticlesGroupByOutput']:
        """Group UsersArticles records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UsersArticles fields to group records by
        where
            UsersArticles filter to select records
        take
            Limit the maximum number of UsersArticles records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UsersArticlesGroupByOutput]
            A list of dictionaries representing the UsersArticles record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UsersArticles records by user_id values
        # and count how many records are in each group
        results = await UsersArticles.prisma().group_by(
            ['user_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models
