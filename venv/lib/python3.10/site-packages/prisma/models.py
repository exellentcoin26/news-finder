# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseConfig, BaseModel, Field, validator

from . import types, enums, errors, fields, bases
from ._types import FuncType
from .builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class Users(bases.BaseUsers):
    """Represents a Users record"""

    id: _int
    username: _str
    created_at: datetime.datetime
    admin: _bool
    login: Optional['models.UserLogins']
    cookies: Optional[List['models.UserCookies']]
    History: Optional[List['models.UsersArticles']]



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UsersKeys']] = None,
        exclude: Optional[Iterable['types.UsersKeys']] = None,
        required: Optional[Iterable['types.UsersKeys']] = None,
        optional: Optional[Iterable['types.UsersKeys']] = None,
        relations: Optional[Mapping['types.UsersRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UsersKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Users_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Users_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Users_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Users_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Users_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Users_relational_fields:
                        raise errors.UnknownRelationalFieldError('Users', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Users / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Users',
            }
        )
        _created_partial_types.add(name)


class UserLogins(bases.BaseUserLogins):
    """Represents a UserLogins record"""

    user: Optional['models.Users']
    id: _int
    password: _str



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserLoginsKeys']] = None,
        exclude: Optional[Iterable['types.UserLoginsKeys']] = None,
        required: Optional[Iterable['types.UserLoginsKeys']] = None,
        optional: Optional[Iterable['types.UserLoginsKeys']] = None,
        relations: Optional[Mapping['types.UserLoginsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserLoginsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _UserLogins_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _UserLogins_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _UserLogins_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _UserLogins_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _UserLogins_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _UserLogins_relational_fields:
                        raise errors.UnknownRelationalFieldError('UserLogins', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid UserLogins / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'UserLogins',
            }
        )
        _created_partial_types.add(name)


class UserCookies(bases.BaseUserCookies):
    """Represents a UserCookies record"""

    user: Optional['models.Users']
    user_id: _int
    cookie: _str



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserCookiesKeys']] = None,
        exclude: Optional[Iterable['types.UserCookiesKeys']] = None,
        required: Optional[Iterable['types.UserCookiesKeys']] = None,
        optional: Optional[Iterable['types.UserCookiesKeys']] = None,
        relations: Optional[Mapping['types.UserCookiesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserCookiesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _UserCookies_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _UserCookies_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _UserCookies_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _UserCookies_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _UserCookies_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _UserCookies_relational_fields:
                        raise errors.UnknownRelationalFieldError('UserCookies', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid UserCookies / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'UserCookies',
            }
        )
        _created_partial_types.add(name)


class NewsSources(bases.BaseNewsSources):
    """Represents a NewsSources record"""

    id: _int
    name: _str
    url: _str
    rss: Optional[List['models.RssEntries']]
    articles: Optional[List['models.NewsArticles']]
    UsersArticles: Optional[List['models.UsersArticles']]



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.NewsSourcesKeys']] = None,
        exclude: Optional[Iterable['types.NewsSourcesKeys']] = None,
        required: Optional[Iterable['types.NewsSourcesKeys']] = None,
        optional: Optional[Iterable['types.NewsSourcesKeys']] = None,
        relations: Optional[Mapping['types.NewsSourcesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.NewsSourcesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _NewsSources_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _NewsSources_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _NewsSources_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _NewsSources_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _NewsSources_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _NewsSources_relational_fields:
                        raise errors.UnknownRelationalFieldError('NewsSources', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid NewsSources / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'NewsSources',
            }
        )
        _created_partial_types.add(name)


class RssEntries(bases.BaseRssEntries):
    """Represents a RssEntries record"""

    source: Optional['models.NewsSources']
    source_id: _int
    feed: _str



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.RssEntriesKeys']] = None,
        exclude: Optional[Iterable['types.RssEntriesKeys']] = None,
        required: Optional[Iterable['types.RssEntriesKeys']] = None,
        optional: Optional[Iterable['types.RssEntriesKeys']] = None,
        relations: Optional[Mapping['types.RssEntriesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.RssEntriesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _RssEntries_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _RssEntries_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _RssEntries_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _RssEntries_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _RssEntries_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _RssEntries_relational_fields:
                        raise errors.UnknownRelationalFieldError('RssEntries', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid RssEntries / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'RssEntries',
            }
        )
        _created_partial_types.add(name)


class NewsArticles(bases.BaseNewsArticles):
    """Represents a NewsArticles record"""

    id: _int
    source: Optional['models.NewsSources']
    source_id: _int
    url: _str
    title: _str
    description: Optional[_str]
    photo: Optional[_str]
    publication_date: Optional[datetime.datetime]
    labels: Optional[List['models.NewsArticleLabels']]
    similar_relation: Optional[List['models.SimilarArticles']]
    similar_articles: Optional[List['models.SimilarArticles']]
    UsersArticles: Optional['models.UsersArticles']



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.NewsArticlesKeys']] = None,
        exclude: Optional[Iterable['types.NewsArticlesKeys']] = None,
        required: Optional[Iterable['types.NewsArticlesKeys']] = None,
        optional: Optional[Iterable['types.NewsArticlesKeys']] = None,
        relations: Optional[Mapping['types.NewsArticlesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.NewsArticlesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _NewsArticles_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _NewsArticles_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _NewsArticles_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _NewsArticles_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _NewsArticles_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _NewsArticles_relational_fields:
                        raise errors.UnknownRelationalFieldError('NewsArticles', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid NewsArticles / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'NewsArticles',
            }
        )
        _created_partial_types.add(name)


class SimilarArticles(bases.BaseSimilarArticles):
    """Represents a SimilarArticles record"""

    article: Optional['models.NewsArticles']
    id1: _int
    similar: Optional['models.NewsArticles']
    id2: _int



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.SimilarArticlesKeys']] = None,
        exclude: Optional[Iterable['types.SimilarArticlesKeys']] = None,
        required: Optional[Iterable['types.SimilarArticlesKeys']] = None,
        optional: Optional[Iterable['types.SimilarArticlesKeys']] = None,
        relations: Optional[Mapping['types.SimilarArticlesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.SimilarArticlesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _SimilarArticles_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _SimilarArticles_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _SimilarArticles_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _SimilarArticles_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _SimilarArticles_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _SimilarArticles_relational_fields:
                        raise errors.UnknownRelationalFieldError('SimilarArticles', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid SimilarArticles / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'SimilarArticles',
            }
        )
        _created_partial_types.add(name)


class NewsArticleLabels(bases.BaseNewsArticleLabels):
    """Represents a NewsArticleLabels record"""

    article: Optional['models.NewsArticles']
    id: _int
    label: _str



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.NewsArticleLabelsKeys']] = None,
        exclude: Optional[Iterable['types.NewsArticleLabelsKeys']] = None,
        required: Optional[Iterable['types.NewsArticleLabelsKeys']] = None,
        optional: Optional[Iterable['types.NewsArticleLabelsKeys']] = None,
        relations: Optional[Mapping['types.NewsArticleLabelsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.NewsArticleLabelsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _NewsArticleLabels_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _NewsArticleLabels_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _NewsArticleLabels_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _NewsArticleLabels_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _NewsArticleLabels_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _NewsArticleLabels_relational_fields:
                        raise errors.UnknownRelationalFieldError('NewsArticleLabels', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid NewsArticleLabels / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'NewsArticleLabels',
            }
        )
        _created_partial_types.add(name)


class UsersArticles(bases.BaseUsersArticles):
    """Represents a UsersArticles record"""

    article: Optional['models.NewsArticles']
    article_id: _int
    source: Optional['models.NewsSources']
    source_id: _int
    url: _str
    user: Optional['models.Users']
    user_id: _int



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UsersArticlesKeys']] = None,
        exclude: Optional[Iterable['types.UsersArticlesKeys']] = None,
        required: Optional[Iterable['types.UsersArticlesKeys']] = None,
        optional: Optional[Iterable['types.UsersArticlesKeys']] = None,
        relations: Optional[Mapping['types.UsersArticlesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UsersArticlesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _UsersArticles_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _UsersArticles_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _UsersArticles_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _UsersArticles_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _UsersArticles_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _UsersArticles_relational_fields:
                        raise errors.UnknownRelationalFieldError('UsersArticles', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid UsersArticles / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'UsersArticles',
            }
        )
        _created_partial_types.add(name)



_Users_relational_fields: Set[str] = {
        'login',
        'cookies',
        'History',
    }
_Users_fields: Dict['types.UsersKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('username', {
            'name': 'username',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('admin', {
            'name': 'admin',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('login', {
            'name': 'login',
            'is_list': False,
            'optional': True,
            'type': 'models.UserLogins',
            'is_relational': True,
            'documentation': None,
        }),
        ('cookies', {
            'name': 'cookies',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserCookies\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('History', {
            'name': 'History',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UsersArticles\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_UserLogins_relational_fields: Set[str] = {
        'user',
    }
_UserLogins_fields: Dict['types.UserLoginsKeys', PartialModelField] = OrderedDict(
    [
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.Users',
            'is_relational': True,
            'documentation': None,
        }),
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('password', {
            'name': 'password',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_UserCookies_relational_fields: Set[str] = {
        'user',
    }
_UserCookies_fields: Dict['types.UserCookiesKeys', PartialModelField] = OrderedDict(
    [
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.Users',
            'is_relational': True,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('cookie', {
            'name': 'cookie',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_NewsSources_relational_fields: Set[str] = {
        'rss',
        'articles',
        'UsersArticles',
    }
_NewsSources_fields: Dict['types.NewsSourcesKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('url', {
            'name': 'url',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('rss', {
            'name': 'rss',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.RssEntries\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('articles', {
            'name': 'articles',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.NewsArticles\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('UsersArticles', {
            'name': 'UsersArticles',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UsersArticles\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_RssEntries_relational_fields: Set[str] = {
        'source',
    }
_RssEntries_fields: Dict['types.RssEntriesKeys', PartialModelField] = OrderedDict(
    [
        ('source', {
            'name': 'source',
            'is_list': False,
            'optional': True,
            'type': 'models.NewsSources',
            'is_relational': True,
            'documentation': None,
        }),
        ('source_id', {
            'name': 'source_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('feed', {
            'name': 'feed',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_NewsArticles_relational_fields: Set[str] = {
        'source',
        'labels',
        'similar_relation',
        'similar_articles',
        'UsersArticles',
    }
_NewsArticles_fields: Dict['types.NewsArticlesKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('source', {
            'name': 'source',
            'is_list': False,
            'optional': True,
            'type': 'models.NewsSources',
            'is_relational': True,
            'documentation': None,
        }),
        ('source_id', {
            'name': 'source_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('url', {
            'name': 'url',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('photo', {
            'name': 'photo',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('publication_date', {
            'name': 'publication_date',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('labels', {
            'name': 'labels',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.NewsArticleLabels\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('similar_relation', {
            'name': 'similar_relation',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.SimilarArticles\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('similar_articles', {
            'name': 'similar_articles',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.SimilarArticles\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('UsersArticles', {
            'name': 'UsersArticles',
            'is_list': False,
            'optional': True,
            'type': 'models.UsersArticles',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_SimilarArticles_relational_fields: Set[str] = {
        'article',
        'similar',
    }
_SimilarArticles_fields: Dict['types.SimilarArticlesKeys', PartialModelField] = OrderedDict(
    [
        ('article', {
            'name': 'article',
            'is_list': False,
            'optional': True,
            'type': 'models.NewsArticles',
            'is_relational': True,
            'documentation': None,
        }),
        ('id1', {
            'name': 'id1',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('similar', {
            'name': 'similar',
            'is_list': False,
            'optional': True,
            'type': 'models.NewsArticles',
            'is_relational': True,
            'documentation': None,
        }),
        ('id2', {
            'name': 'id2',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_NewsArticleLabels_relational_fields: Set[str] = {
        'article',
    }
_NewsArticleLabels_fields: Dict['types.NewsArticleLabelsKeys', PartialModelField] = OrderedDict(
    [
        ('article', {
            'name': 'article',
            'is_list': False,
            'optional': True,
            'type': 'models.NewsArticles',
            'is_relational': True,
            'documentation': None,
        }),
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('label', {
            'name': 'label',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_UsersArticles_relational_fields: Set[str] = {
        'article',
        'source',
        'user',
    }
_UsersArticles_fields: Dict['types.UsersArticlesKeys', PartialModelField] = OrderedDict(
    [
        ('article', {
            'name': 'article',
            'is_list': False,
            'optional': True,
            'type': 'models.NewsArticles',
            'is_relational': True,
            'documentation': None,
        }),
        ('article_id', {
            'name': 'article_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('source', {
            'name': 'source',
            'is_list': False,
            'optional': True,
            'type': 'models.NewsSources',
            'is_relational': True,
            'documentation': None,
        }),
        ('source_id', {
            'name': 'source_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('url', {
            'name': 'url',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.Users',
            'is_relational': True,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
Users.update_forward_refs()
UserLogins.update_forward_refs()
UserCookies.update_forward_refs()
NewsSources.update_forward_refs()
RssEntries.update_forward_refs()
NewsArticles.update_forward_refs()
SimilarArticles.update_forward_refs()
NewsArticleLabels.update_forward_refs()
UsersArticles.update_forward_refs()
