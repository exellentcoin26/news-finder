# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = Literal['default', 'insensitive']
SortOrder = Literal['asc', 'desc']


class _DatasourceOverrideOptional(TypedDict, total=False):
    env: str
    name: str


class DatasourceOverride(_DatasourceOverrideOptional):
    url: str


# NOTE: we don't support some options as their type hints are not publicly exposed
# https://github.com/encode/httpx/discussions/1977
class HttpConfig(TypedDict, total=False):
    app: Callable[[Mapping[str, Any], Any], Any]
    http1: bool
    http2: bool
    limits: httpx.Limits
    timeout: Union[None, float, httpx.Timeout]
    trust_env: bool
    max_redirects: int


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List['Serializable'],
    Dict[None, 'Serializable'],
    Dict[bool, 'Serializable'],
    Dict[float, 'Serializable'],
    Dict[int, 'Serializable'],
    Dict[str, 'Serializable'],
]


StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilter'],
        'mode': SortMode,
    },
    total=False,
)



class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilter'],
    },
    total=False,
)



class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilter'],
    },
    total=False,
)



class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilter'],
    },
    total=False,
)



class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilter'],
    },
    total=False,
)



class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilter'],
    },
    total=False,
)



class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilter'],
    },
    total=False,
)



class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# Users types

class UsersOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Users create method"""
    id: _int
    created_at: datetime.datetime
    admin: _bool
    login: 'UserLoginsCreateNestedWithoutRelationsInput'
    cookies: 'UserCookiesCreateManyNestedWithoutRelationsInput'
    History: 'UsersArticlesCreateManyNestedWithoutRelationsInput'


class UsersCreateInput(UsersOptionalCreateInput):
    """Required arguments to the Users create method"""
    username: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UsersOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Users create method, without relations"""
    id: _int
    created_at: datetime.datetime
    admin: _bool


class UsersCreateWithoutRelationsInput(UsersOptionalCreateWithoutRelationsInput):
    """Required arguments to the Users create method, without relations"""
    username: _str


class UsersCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UsersCreateWithoutRelationsInput'
    connect: 'UsersWhereUniqueInput'


class UsersCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UsersCreateWithoutRelationsInput', List['UsersCreateWithoutRelationsInput']]
    connect: Union['UsersWhereUniqueInput', List['UsersWhereUniqueInput']]


_UsersWhereUnique_id_Input = TypedDict(
    '_UsersWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_UsersWhereUnique_username_Input = TypedDict(
    '_UsersWhereUnique_username_Input',
    {
        'username': '_str',
    },
    total=True
)

UsersWhereUniqueInput = Union[
    '_UsersWhereUnique_id_Input',
    '_UsersWhereUnique_username_Input',
]


class UsersUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    username: _str
    created_at: datetime.datetime
    admin: _bool
    login: 'UserLoginsUpdateOneWithoutRelationsInput'
    cookies: 'UserCookiesUpdateManyWithoutRelationsInput'
    History: 'UsersArticlesUpdateManyWithoutRelationsInput'


class UsersUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    username: _str
    created_at: datetime.datetime
    admin: _bool


class UsersUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UsersCreateWithoutRelationsInput']
    connect: List['UsersWhereUniqueInput']
    set: List['UsersWhereUniqueInput']
    disconnect: List['UsersWhereUniqueInput']
    delete: List['UsersWhereUniqueInput']

    # TODO
    # update: List['UsersUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UsersUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UsersScalarWhereInput']
    # upsert: List['UsersUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['UsersCreateOrConnectWithoutRelationsInput']


class UsersUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UsersCreateWithoutRelationsInput'
    connect: 'UsersWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UsersUpdateInput'
    # upsert: 'UsersUpsertWithoutRelationsInput'
    # connectOrCreate: 'UsersCreateOrConnectWithoutRelationsInput'


class UsersUpsertInput(TypedDict):
    create: 'UsersCreateInput'
    update: 'UsersUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Users_id_OrderByInput = TypedDict(
    '_Users_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Users_username_OrderByInput = TypedDict(
    '_Users_username_OrderByInput',
    {
        'username': 'SortOrder',
    },
    total=True
)

_Users_created_at_OrderByInput = TypedDict(
    '_Users_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_Users_admin_OrderByInput = TypedDict(
    '_Users_admin_OrderByInput',
    {
        'admin': 'SortOrder',
    },
    total=True
)

UsersOrderByInput = Union[
    '_Users_id_OrderByInput',
    '_Users_username_OrderByInput',
    '_Users_created_at_OrderByInput',
    '_Users_admin_OrderByInput',
]



# recursive Users types
# TODO: cleanup these types



UsersRelationFilter = TypedDict(
    'UsersRelationFilter',
    {
        'is': 'UsersWhereInput',
        'is_not': 'UsersWhereInput',
    },
    total=False,
)


class UsersListRelationFilter(TypedDict, total=False):
    some: 'UsersWhereInput'
    none: 'UsersWhereInput'
    every: 'UsersWhereInput'


class UsersInclude(TypedDict, total=False):
    """Users relational arguments"""
    login: Union[bool, 'UserLoginsArgsFromUsers']
    cookies: Union[bool, 'FindManyUserCookiesArgsFromUsers']
    History: Union[bool, 'FindManyUsersArticlesArgsFromUsers']


class UsersIncludeFromUsers(TypedDict, total=False):
    """Relational arguments for Users"""
    login: Union[bool, 'UserLoginsArgsFromUsers']
    cookies: Union[bool, 'FindManyUserCookiesArgsFromUsers']
    History: Union[bool, 'FindManyUsersArticlesArgsFromUsers']


class UsersArgsFromUsers(TypedDict, total=False):
    """Arguments for Users"""
    include: 'UsersIncludeFromUsers'


class FindManyUsersArgsFromUsers(TypedDict, total=False):
    """Arguments for Users"""
    take: int
    skip: int
    order_by: Union['UsersOrderByInput', List['UsersOrderByInput']]
    where: 'UsersWhereInput'
    cursor: 'UsersWhereUniqueInput'
    distinct: List['UsersScalarFieldKeys']
    include: 'UsersIncludeFromUsers'


class UserLoginsIncludeFromUsers(TypedDict, total=False):
    """Relational arguments for Users"""
    user: Union[bool, 'UsersArgsFromUsers']


class UserLoginsArgsFromUsers(TypedDict, total=False):
    """Arguments for Users"""
    include: 'UserLoginsIncludeFromUserLogins'


class FindManyUserLoginsArgsFromUsers(TypedDict, total=False):
    """Arguments for Users"""
    take: int
    skip: int
    order_by: Union['UserLoginsOrderByInput', List['UserLoginsOrderByInput']]
    where: 'UserLoginsWhereInput'
    cursor: 'UserLoginsWhereUniqueInput'
    distinct: List['UserLoginsScalarFieldKeys']
    include: 'UserLoginsIncludeFromUserLogins'


class UserCookiesIncludeFromUsers(TypedDict, total=False):
    """Relational arguments for Users"""
    user: Union[bool, 'UsersArgsFromUsers']


class UserCookiesArgsFromUsers(TypedDict, total=False):
    """Arguments for Users"""
    include: 'UserCookiesIncludeFromUserCookies'


class FindManyUserCookiesArgsFromUsers(TypedDict, total=False):
    """Arguments for Users"""
    take: int
    skip: int
    order_by: Union['UserCookiesOrderByInput', List['UserCookiesOrderByInput']]
    where: 'UserCookiesWhereInput'
    cursor: 'UserCookiesWhereUniqueInput'
    distinct: List['UserCookiesScalarFieldKeys']
    include: 'UserCookiesIncludeFromUserCookies'


class NewsSourcesIncludeFromUsers(TypedDict, total=False):
    """Relational arguments for Users"""
    rss: Union[bool, 'FindManyRssEntriesArgsFromUsers']
    articles: Union[bool, 'FindManyNewsArticlesArgsFromUsers']
    UsersArticles: Union[bool, 'FindManyUsersArticlesArgsFromUsers']


class NewsSourcesArgsFromUsers(TypedDict, total=False):
    """Arguments for Users"""
    include: 'NewsSourcesIncludeFromNewsSources'


class FindManyNewsSourcesArgsFromUsers(TypedDict, total=False):
    """Arguments for Users"""
    take: int
    skip: int
    order_by: Union['NewsSourcesOrderByInput', List['NewsSourcesOrderByInput']]
    where: 'NewsSourcesWhereInput'
    cursor: 'NewsSourcesWhereUniqueInput'
    distinct: List['NewsSourcesScalarFieldKeys']
    include: 'NewsSourcesIncludeFromNewsSources'


class RssEntriesIncludeFromUsers(TypedDict, total=False):
    """Relational arguments for Users"""
    source: Union[bool, 'NewsSourcesArgsFromUsers']


class RssEntriesArgsFromUsers(TypedDict, total=False):
    """Arguments for Users"""
    include: 'RssEntriesIncludeFromRssEntries'


class FindManyRssEntriesArgsFromUsers(TypedDict, total=False):
    """Arguments for Users"""
    take: int
    skip: int
    order_by: Union['RssEntriesOrderByInput', List['RssEntriesOrderByInput']]
    where: 'RssEntriesWhereInput'
    cursor: 'RssEntriesWhereUniqueInput'
    distinct: List['RssEntriesScalarFieldKeys']
    include: 'RssEntriesIncludeFromRssEntries'


class NewsArticlesIncludeFromUsers(TypedDict, total=False):
    """Relational arguments for Users"""
    source: Union[bool, 'NewsSourcesArgsFromUsers']
    labels: Union[bool, 'FindManyNewsArticleLabelsArgsFromUsers']
    similar_relation: Union[bool, 'FindManySimilarArticlesArgsFromUsers']
    similar_articles: Union[bool, 'FindManySimilarArticlesArgsFromUsers']
    UsersArticles: Union[bool, 'UsersArticlesArgsFromUsers']


class NewsArticlesArgsFromUsers(TypedDict, total=False):
    """Arguments for Users"""
    include: 'NewsArticlesIncludeFromNewsArticles'


class FindManyNewsArticlesArgsFromUsers(TypedDict, total=False):
    """Arguments for Users"""
    take: int
    skip: int
    order_by: Union['NewsArticlesOrderByInput', List['NewsArticlesOrderByInput']]
    where: 'NewsArticlesWhereInput'
    cursor: 'NewsArticlesWhereUniqueInput'
    distinct: List['NewsArticlesScalarFieldKeys']
    include: 'NewsArticlesIncludeFromNewsArticles'


class SimilarArticlesIncludeFromUsers(TypedDict, total=False):
    """Relational arguments for Users"""
    article: Union[bool, 'NewsArticlesArgsFromUsers']
    similar: Union[bool, 'NewsArticlesArgsFromUsers']


class SimilarArticlesArgsFromUsers(TypedDict, total=False):
    """Arguments for Users"""
    include: 'SimilarArticlesIncludeFromSimilarArticles'


class FindManySimilarArticlesArgsFromUsers(TypedDict, total=False):
    """Arguments for Users"""
    take: int
    skip: int
    order_by: Union['SimilarArticlesOrderByInput', List['SimilarArticlesOrderByInput']]
    where: 'SimilarArticlesWhereInput'
    cursor: 'SimilarArticlesWhereUniqueInput'
    distinct: List['SimilarArticlesScalarFieldKeys']
    include: 'SimilarArticlesIncludeFromSimilarArticles'


class NewsArticleLabelsIncludeFromUsers(TypedDict, total=False):
    """Relational arguments for Users"""
    article: Union[bool, 'NewsArticlesArgsFromUsers']


class NewsArticleLabelsArgsFromUsers(TypedDict, total=False):
    """Arguments for Users"""
    include: 'NewsArticleLabelsIncludeFromNewsArticleLabels'


class FindManyNewsArticleLabelsArgsFromUsers(TypedDict, total=False):
    """Arguments for Users"""
    take: int
    skip: int
    order_by: Union['NewsArticleLabelsOrderByInput', List['NewsArticleLabelsOrderByInput']]
    where: 'NewsArticleLabelsWhereInput'
    cursor: 'NewsArticleLabelsWhereUniqueInput'
    distinct: List['NewsArticleLabelsScalarFieldKeys']
    include: 'NewsArticleLabelsIncludeFromNewsArticleLabels'


class UsersArticlesIncludeFromUsers(TypedDict, total=False):
    """Relational arguments for Users"""
    article: Union[bool, 'NewsArticlesArgsFromUsers']
    source: Union[bool, 'NewsSourcesArgsFromUsers']
    user: Union[bool, 'UsersArgsFromUsers']


class UsersArticlesArgsFromUsers(TypedDict, total=False):
    """Arguments for Users"""
    include: 'UsersArticlesIncludeFromUsersArticles'


class FindManyUsersArticlesArgsFromUsers(TypedDict, total=False):
    """Arguments for Users"""
    take: int
    skip: int
    order_by: Union['UsersArticlesOrderByInput', List['UsersArticlesOrderByInput']]
    where: 'UsersArticlesWhereInput'
    cursor: 'UsersArticlesWhereUniqueInput'
    distinct: List['UsersArticlesScalarFieldKeys']
    include: 'UsersArticlesIncludeFromUsersArticles'




FindManyUsersArgs = FindManyUsersArgsFromUsers
FindFirstUsersArgs = FindManyUsersArgsFromUsers


class UsersWhereInput(TypedDict, total=False):
    """Users arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    username: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    admin: Union[_bool, 'types.BooleanFilter']
    login: 'UserLoginsRelationFilter'
    cookies: 'UserCookiesListRelationFilter'
    History: 'UsersArticlesListRelationFilter'

    # should be noted that AND and NOT should be Union['UsersWhereInput', List['UsersWhereInput']]
    # but this causes mypy to hang :/
    AND: List['UsersWhereInput']
    OR: List['UsersWhereInput']
    NOT: List['UsersWhereInput']



# aggregate Users types


class UsersScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Users arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    admin: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['UsersScalarWhereWithAggregatesInput']
    OR: List['UsersScalarWhereWithAggregatesInput']
    NOT: List['UsersScalarWhereWithAggregatesInput']



class UsersGroupByOutput(TypedDict, total=False):
    id: _int
    username: _str
    created_at: datetime.datetime
    admin: _bool
    _sum: 'UsersSumAggregateOutput'
    _avg: 'UsersAvgAggregateOutput'
    _min: 'UsersMinAggregateOutput'
    _max: 'UsersMaxAggregateOutput'
    _count: 'UsersCountAggregateOutput'


class UsersAvgAggregateOutput(TypedDict, total=False):
    """Users output for aggregating averages"""
    id: float


class UsersSumAggregateOutput(TypedDict, total=False):
    """Users output for aggregating sums"""
    id: _int


class UsersScalarAggregateOutput(TypedDict, total=False):
    """Users output including scalar fields"""
    id: _int
    username: _str
    created_at: datetime.datetime
    admin: _bool


UsersMinAggregateOutput = UsersScalarAggregateOutput
UsersMaxAggregateOutput = UsersScalarAggregateOutput


class UsersMaxAggregateInput(TypedDict, total=False):
    """Users input for aggregating by max"""
    id: bool
    username: bool
    created_at: bool
    admin: bool


class UsersMinAggregateInput(TypedDict, total=False):
    """Users input for aggregating by min"""
    id: bool
    username: bool
    created_at: bool
    admin: bool


class UsersNumberAggregateInput(TypedDict, total=False):
    """Users input for aggregating numbers"""
    id: bool


UsersAvgAggregateInput = UsersNumberAggregateInput
UsersSumAggregateInput = UsersNumberAggregateInput


UsersCountAggregateInput = TypedDict(
    'UsersCountAggregateInput',
    {
        'id': bool,
        'username': bool,
        'created_at': bool,
        'admin': bool,
        '_all': bool,
    },
    total=False,
)

UsersCountAggregateOutput = TypedDict(
    'UsersCountAggregateOutput',
    {
        'id': int,
        'username': int,
        'created_at': int,
        'admin': int,
        '_all': int,
    },
    total=False,
)


UsersKeys = Literal[
    'id',
    'username',
    'created_at',
    'admin',
    'login',
    'cookies',
    'History',
]
UsersScalarFieldKeys = Literal[
    'id',
    'username',
    'created_at',
    'admin',
]
UsersScalarFieldKeysT = TypeVar('UsersScalarFieldKeysT', bound=UsersScalarFieldKeys)

UsersRelationalFieldKeys = Literal[
        'login',
        'cookies',
        'History',
    ]

# UserLogins types

class UserLoginsOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the UserLogins create method"""
    user: 'UsersCreateNestedWithoutRelationsInput'
    id: _int


class UserLoginsCreateInput(UserLoginsOptionalCreateInput):
    """Required arguments to the UserLogins create method"""
    password: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserLoginsOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the UserLogins create method, without relations"""
    id: _int


class UserLoginsCreateWithoutRelationsInput(UserLoginsOptionalCreateWithoutRelationsInput):
    """Required arguments to the UserLogins create method, without relations"""
    password: _str


class UserLoginsCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserLoginsCreateWithoutRelationsInput'
    connect: 'UserLoginsWhereUniqueInput'


class UserLoginsCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserLoginsCreateWithoutRelationsInput', List['UserLoginsCreateWithoutRelationsInput']]
    connect: Union['UserLoginsWhereUniqueInput', List['UserLoginsWhereUniqueInput']]


_UserLoginsWhereUnique_id_Input = TypedDict(
    '_UserLoginsWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

UserLoginsWhereUniqueInput = _UserLoginsWhereUnique_id_Input


class UserLoginsUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    user: 'UsersUpdateOneWithoutRelationsInput'
    password: _str


class UserLoginsUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    password: _str


class UserLoginsUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserLoginsCreateWithoutRelationsInput']
    connect: List['UserLoginsWhereUniqueInput']
    set: List['UserLoginsWhereUniqueInput']
    disconnect: List['UserLoginsWhereUniqueInput']
    delete: List['UserLoginsWhereUniqueInput']

    # TODO
    # update: List['UserLoginsUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserLoginsUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserLoginsScalarWhereInput']
    # upsert: List['UserLoginsUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['UserLoginsCreateOrConnectWithoutRelationsInput']


class UserLoginsUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserLoginsCreateWithoutRelationsInput'
    connect: 'UserLoginsWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserLoginsUpdateInput'
    # upsert: 'UserLoginsUpsertWithoutRelationsInput'
    # connectOrCreate: 'UserLoginsCreateOrConnectWithoutRelationsInput'


class UserLoginsUpsertInput(TypedDict):
    create: 'UserLoginsCreateInput'
    update: 'UserLoginsUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_UserLogins_id_OrderByInput = TypedDict(
    '_UserLogins_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_UserLogins_password_OrderByInput = TypedDict(
    '_UserLogins_password_OrderByInput',
    {
        'password': 'SortOrder',
    },
    total=True
)

UserLoginsOrderByInput = Union[
    '_UserLogins_id_OrderByInput',
    '_UserLogins_password_OrderByInput',
]



# recursive UserLogins types
# TODO: cleanup these types



UserLoginsRelationFilter = TypedDict(
    'UserLoginsRelationFilter',
    {
        'is': 'UserLoginsWhereInput',
        'is_not': 'UserLoginsWhereInput',
    },
    total=False,
)


class UserLoginsListRelationFilter(TypedDict, total=False):
    some: 'UserLoginsWhereInput'
    none: 'UserLoginsWhereInput'
    every: 'UserLoginsWhereInput'


class UserLoginsInclude(TypedDict, total=False):
    """UserLogins relational arguments"""
    user: Union[bool, 'UsersArgsFromUserLogins']


class UsersIncludeFromUserLogins(TypedDict, total=False):
    """Relational arguments for UserLogins"""
    login: Union[bool, 'UserLoginsArgsFromUserLogins']
    cookies: Union[bool, 'FindManyUserCookiesArgsFromUserLogins']
    History: Union[bool, 'FindManyUsersArticlesArgsFromUserLogins']


class UsersArgsFromUserLogins(TypedDict, total=False):
    """Arguments for UserLogins"""
    include: 'UsersIncludeFromUsers'


class FindManyUsersArgsFromUserLogins(TypedDict, total=False):
    """Arguments for UserLogins"""
    take: int
    skip: int
    order_by: Union['UsersOrderByInput', List['UsersOrderByInput']]
    where: 'UsersWhereInput'
    cursor: 'UsersWhereUniqueInput'
    distinct: List['UsersScalarFieldKeys']
    include: 'UsersIncludeFromUsers'


class UserLoginsIncludeFromUserLogins(TypedDict, total=False):
    """Relational arguments for UserLogins"""
    user: Union[bool, 'UsersArgsFromUserLogins']


class UserLoginsArgsFromUserLogins(TypedDict, total=False):
    """Arguments for UserLogins"""
    include: 'UserLoginsIncludeFromUserLogins'


class FindManyUserLoginsArgsFromUserLogins(TypedDict, total=False):
    """Arguments for UserLogins"""
    take: int
    skip: int
    order_by: Union['UserLoginsOrderByInput', List['UserLoginsOrderByInput']]
    where: 'UserLoginsWhereInput'
    cursor: 'UserLoginsWhereUniqueInput'
    distinct: List['UserLoginsScalarFieldKeys']
    include: 'UserLoginsIncludeFromUserLogins'


class UserCookiesIncludeFromUserLogins(TypedDict, total=False):
    """Relational arguments for UserLogins"""
    user: Union[bool, 'UsersArgsFromUserLogins']


class UserCookiesArgsFromUserLogins(TypedDict, total=False):
    """Arguments for UserLogins"""
    include: 'UserCookiesIncludeFromUserCookies'


class FindManyUserCookiesArgsFromUserLogins(TypedDict, total=False):
    """Arguments for UserLogins"""
    take: int
    skip: int
    order_by: Union['UserCookiesOrderByInput', List['UserCookiesOrderByInput']]
    where: 'UserCookiesWhereInput'
    cursor: 'UserCookiesWhereUniqueInput'
    distinct: List['UserCookiesScalarFieldKeys']
    include: 'UserCookiesIncludeFromUserCookies'


class NewsSourcesIncludeFromUserLogins(TypedDict, total=False):
    """Relational arguments for UserLogins"""
    rss: Union[bool, 'FindManyRssEntriesArgsFromUserLogins']
    articles: Union[bool, 'FindManyNewsArticlesArgsFromUserLogins']
    UsersArticles: Union[bool, 'FindManyUsersArticlesArgsFromUserLogins']


class NewsSourcesArgsFromUserLogins(TypedDict, total=False):
    """Arguments for UserLogins"""
    include: 'NewsSourcesIncludeFromNewsSources'


class FindManyNewsSourcesArgsFromUserLogins(TypedDict, total=False):
    """Arguments for UserLogins"""
    take: int
    skip: int
    order_by: Union['NewsSourcesOrderByInput', List['NewsSourcesOrderByInput']]
    where: 'NewsSourcesWhereInput'
    cursor: 'NewsSourcesWhereUniqueInput'
    distinct: List['NewsSourcesScalarFieldKeys']
    include: 'NewsSourcesIncludeFromNewsSources'


class RssEntriesIncludeFromUserLogins(TypedDict, total=False):
    """Relational arguments for UserLogins"""
    source: Union[bool, 'NewsSourcesArgsFromUserLogins']


class RssEntriesArgsFromUserLogins(TypedDict, total=False):
    """Arguments for UserLogins"""
    include: 'RssEntriesIncludeFromRssEntries'


class FindManyRssEntriesArgsFromUserLogins(TypedDict, total=False):
    """Arguments for UserLogins"""
    take: int
    skip: int
    order_by: Union['RssEntriesOrderByInput', List['RssEntriesOrderByInput']]
    where: 'RssEntriesWhereInput'
    cursor: 'RssEntriesWhereUniqueInput'
    distinct: List['RssEntriesScalarFieldKeys']
    include: 'RssEntriesIncludeFromRssEntries'


class NewsArticlesIncludeFromUserLogins(TypedDict, total=False):
    """Relational arguments for UserLogins"""
    source: Union[bool, 'NewsSourcesArgsFromUserLogins']
    labels: Union[bool, 'FindManyNewsArticleLabelsArgsFromUserLogins']
    similar_relation: Union[bool, 'FindManySimilarArticlesArgsFromUserLogins']
    similar_articles: Union[bool, 'FindManySimilarArticlesArgsFromUserLogins']
    UsersArticles: Union[bool, 'UsersArticlesArgsFromUserLogins']


class NewsArticlesArgsFromUserLogins(TypedDict, total=False):
    """Arguments for UserLogins"""
    include: 'NewsArticlesIncludeFromNewsArticles'


class FindManyNewsArticlesArgsFromUserLogins(TypedDict, total=False):
    """Arguments for UserLogins"""
    take: int
    skip: int
    order_by: Union['NewsArticlesOrderByInput', List['NewsArticlesOrderByInput']]
    where: 'NewsArticlesWhereInput'
    cursor: 'NewsArticlesWhereUniqueInput'
    distinct: List['NewsArticlesScalarFieldKeys']
    include: 'NewsArticlesIncludeFromNewsArticles'


class SimilarArticlesIncludeFromUserLogins(TypedDict, total=False):
    """Relational arguments for UserLogins"""
    article: Union[bool, 'NewsArticlesArgsFromUserLogins']
    similar: Union[bool, 'NewsArticlesArgsFromUserLogins']


class SimilarArticlesArgsFromUserLogins(TypedDict, total=False):
    """Arguments for UserLogins"""
    include: 'SimilarArticlesIncludeFromSimilarArticles'


class FindManySimilarArticlesArgsFromUserLogins(TypedDict, total=False):
    """Arguments for UserLogins"""
    take: int
    skip: int
    order_by: Union['SimilarArticlesOrderByInput', List['SimilarArticlesOrderByInput']]
    where: 'SimilarArticlesWhereInput'
    cursor: 'SimilarArticlesWhereUniqueInput'
    distinct: List['SimilarArticlesScalarFieldKeys']
    include: 'SimilarArticlesIncludeFromSimilarArticles'


class NewsArticleLabelsIncludeFromUserLogins(TypedDict, total=False):
    """Relational arguments for UserLogins"""
    article: Union[bool, 'NewsArticlesArgsFromUserLogins']


class NewsArticleLabelsArgsFromUserLogins(TypedDict, total=False):
    """Arguments for UserLogins"""
    include: 'NewsArticleLabelsIncludeFromNewsArticleLabels'


class FindManyNewsArticleLabelsArgsFromUserLogins(TypedDict, total=False):
    """Arguments for UserLogins"""
    take: int
    skip: int
    order_by: Union['NewsArticleLabelsOrderByInput', List['NewsArticleLabelsOrderByInput']]
    where: 'NewsArticleLabelsWhereInput'
    cursor: 'NewsArticleLabelsWhereUniqueInput'
    distinct: List['NewsArticleLabelsScalarFieldKeys']
    include: 'NewsArticleLabelsIncludeFromNewsArticleLabels'


class UsersArticlesIncludeFromUserLogins(TypedDict, total=False):
    """Relational arguments for UserLogins"""
    article: Union[bool, 'NewsArticlesArgsFromUserLogins']
    source: Union[bool, 'NewsSourcesArgsFromUserLogins']
    user: Union[bool, 'UsersArgsFromUserLogins']


class UsersArticlesArgsFromUserLogins(TypedDict, total=False):
    """Arguments for UserLogins"""
    include: 'UsersArticlesIncludeFromUsersArticles'


class FindManyUsersArticlesArgsFromUserLogins(TypedDict, total=False):
    """Arguments for UserLogins"""
    take: int
    skip: int
    order_by: Union['UsersArticlesOrderByInput', List['UsersArticlesOrderByInput']]
    where: 'UsersArticlesWhereInput'
    cursor: 'UsersArticlesWhereUniqueInput'
    distinct: List['UsersArticlesScalarFieldKeys']
    include: 'UsersArticlesIncludeFromUsersArticles'




FindManyUserLoginsArgs = FindManyUserLoginsArgsFromUserLogins
FindFirstUserLoginsArgs = FindManyUserLoginsArgsFromUserLogins


class UserLoginsWhereInput(TypedDict, total=False):
    """UserLogins arguments for searching"""
    user: 'UsersRelationFilter'
    id: Union[_int, 'types.IntFilter']
    password: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['UserLoginsWhereInput', List['UserLoginsWhereInput']]
    # but this causes mypy to hang :/
    AND: List['UserLoginsWhereInput']
    OR: List['UserLoginsWhereInput']
    NOT: List['UserLoginsWhereInput']



# aggregate UserLogins types


class UserLoginsScalarWhereWithAggregatesInput(TypedDict, total=False):
    """UserLogins arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['UserLoginsScalarWhereWithAggregatesInput']
    OR: List['UserLoginsScalarWhereWithAggregatesInput']
    NOT: List['UserLoginsScalarWhereWithAggregatesInput']



class UserLoginsGroupByOutput(TypedDict, total=False):
    id: _int
    password: _str
    _sum: 'UserLoginsSumAggregateOutput'
    _avg: 'UserLoginsAvgAggregateOutput'
    _min: 'UserLoginsMinAggregateOutput'
    _max: 'UserLoginsMaxAggregateOutput'
    _count: 'UserLoginsCountAggregateOutput'


class UserLoginsAvgAggregateOutput(TypedDict, total=False):
    """UserLogins output for aggregating averages"""
    id: float


class UserLoginsSumAggregateOutput(TypedDict, total=False):
    """UserLogins output for aggregating sums"""
    id: _int


class UserLoginsScalarAggregateOutput(TypedDict, total=False):
    """UserLogins output including scalar fields"""
    id: _int
    password: _str


UserLoginsMinAggregateOutput = UserLoginsScalarAggregateOutput
UserLoginsMaxAggregateOutput = UserLoginsScalarAggregateOutput


class UserLoginsMaxAggregateInput(TypedDict, total=False):
    """UserLogins input for aggregating by max"""
    id: bool
    password: bool


class UserLoginsMinAggregateInput(TypedDict, total=False):
    """UserLogins input for aggregating by min"""
    id: bool
    password: bool


class UserLoginsNumberAggregateInput(TypedDict, total=False):
    """UserLogins input for aggregating numbers"""
    id: bool


UserLoginsAvgAggregateInput = UserLoginsNumberAggregateInput
UserLoginsSumAggregateInput = UserLoginsNumberAggregateInput


UserLoginsCountAggregateInput = TypedDict(
    'UserLoginsCountAggregateInput',
    {
        'id': bool,
        'password': bool,
        '_all': bool,
    },
    total=False,
)

UserLoginsCountAggregateOutput = TypedDict(
    'UserLoginsCountAggregateOutput',
    {
        'id': int,
        'password': int,
        '_all': int,
    },
    total=False,
)


UserLoginsKeys = Literal[
    'user',
    'id',
    'password',
]
UserLoginsScalarFieldKeys = Literal[
    'id',
    'password',
]
UserLoginsScalarFieldKeysT = TypeVar('UserLoginsScalarFieldKeysT', bound=UserLoginsScalarFieldKeys)

UserLoginsRelationalFieldKeys = Literal[
        'user',
    ]

# UserCookies types

class UserCookiesOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the UserCookies create method"""
    user: 'UsersCreateNestedWithoutRelationsInput'
    user_id: _int


class UserCookiesCreateInput(UserCookiesOptionalCreateInput):
    """Required arguments to the UserCookies create method"""
    cookie: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserCookiesOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the UserCookies create method, without relations"""
    user_id: _int


class UserCookiesCreateWithoutRelationsInput(UserCookiesOptionalCreateWithoutRelationsInput):
    """Required arguments to the UserCookies create method, without relations"""
    cookie: _str


class UserCookiesCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCookiesCreateWithoutRelationsInput'
    connect: 'UserCookiesWhereUniqueInput'


class UserCookiesCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserCookiesCreateWithoutRelationsInput', List['UserCookiesCreateWithoutRelationsInput']]
    connect: Union['UserCookiesWhereUniqueInput', List['UserCookiesWhereUniqueInput']]


_UserCookiesWhereUnique_cookie_Input = TypedDict(
    '_UserCookiesWhereUnique_cookie_Input',
    {
        'cookie': '_str',
    },
    total=True
)

UserCookiesWhereUniqueInput = _UserCookiesWhereUnique_cookie_Input


class UserCookiesUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    user: 'UsersUpdateOneWithoutRelationsInput'
    cookie: _str


class UserCookiesUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    cookie: _str


class UserCookiesUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserCookiesCreateWithoutRelationsInput']
    connect: List['UserCookiesWhereUniqueInput']
    set: List['UserCookiesWhereUniqueInput']
    disconnect: List['UserCookiesWhereUniqueInput']
    delete: List['UserCookiesWhereUniqueInput']

    # TODO
    # update: List['UserCookiesUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserCookiesUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserCookiesScalarWhereInput']
    # upsert: List['UserCookiesUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['UserCookiesCreateOrConnectWithoutRelationsInput']


class UserCookiesUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCookiesCreateWithoutRelationsInput'
    connect: 'UserCookiesWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserCookiesUpdateInput'
    # upsert: 'UserCookiesUpsertWithoutRelationsInput'
    # connectOrCreate: 'UserCookiesCreateOrConnectWithoutRelationsInput'


class UserCookiesUpsertInput(TypedDict):
    create: 'UserCookiesCreateInput'
    update: 'UserCookiesUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_UserCookies_user_id_OrderByInput = TypedDict(
    '_UserCookies_user_id_OrderByInput',
    {
        'user_id': 'SortOrder',
    },
    total=True
)

_UserCookies_cookie_OrderByInput = TypedDict(
    '_UserCookies_cookie_OrderByInput',
    {
        'cookie': 'SortOrder',
    },
    total=True
)

UserCookiesOrderByInput = Union[
    '_UserCookies_user_id_OrderByInput',
    '_UserCookies_cookie_OrderByInput',
]



# recursive UserCookies types
# TODO: cleanup these types



UserCookiesRelationFilter = TypedDict(
    'UserCookiesRelationFilter',
    {
        'is': 'UserCookiesWhereInput',
        'is_not': 'UserCookiesWhereInput',
    },
    total=False,
)


class UserCookiesListRelationFilter(TypedDict, total=False):
    some: 'UserCookiesWhereInput'
    none: 'UserCookiesWhereInput'
    every: 'UserCookiesWhereInput'


class UserCookiesInclude(TypedDict, total=False):
    """UserCookies relational arguments"""
    user: Union[bool, 'UsersArgsFromUserCookies']


class UsersIncludeFromUserCookies(TypedDict, total=False):
    """Relational arguments for UserCookies"""
    login: Union[bool, 'UserLoginsArgsFromUserCookies']
    cookies: Union[bool, 'FindManyUserCookiesArgsFromUserCookies']
    History: Union[bool, 'FindManyUsersArticlesArgsFromUserCookies']


class UsersArgsFromUserCookies(TypedDict, total=False):
    """Arguments for UserCookies"""
    include: 'UsersIncludeFromUsers'


class FindManyUsersArgsFromUserCookies(TypedDict, total=False):
    """Arguments for UserCookies"""
    take: int
    skip: int
    order_by: Union['UsersOrderByInput', List['UsersOrderByInput']]
    where: 'UsersWhereInput'
    cursor: 'UsersWhereUniqueInput'
    distinct: List['UsersScalarFieldKeys']
    include: 'UsersIncludeFromUsers'


class UserLoginsIncludeFromUserCookies(TypedDict, total=False):
    """Relational arguments for UserCookies"""
    user: Union[bool, 'UsersArgsFromUserCookies']


class UserLoginsArgsFromUserCookies(TypedDict, total=False):
    """Arguments for UserCookies"""
    include: 'UserLoginsIncludeFromUserLogins'


class FindManyUserLoginsArgsFromUserCookies(TypedDict, total=False):
    """Arguments for UserCookies"""
    take: int
    skip: int
    order_by: Union['UserLoginsOrderByInput', List['UserLoginsOrderByInput']]
    where: 'UserLoginsWhereInput'
    cursor: 'UserLoginsWhereUniqueInput'
    distinct: List['UserLoginsScalarFieldKeys']
    include: 'UserLoginsIncludeFromUserLogins'


class UserCookiesIncludeFromUserCookies(TypedDict, total=False):
    """Relational arguments for UserCookies"""
    user: Union[bool, 'UsersArgsFromUserCookies']


class UserCookiesArgsFromUserCookies(TypedDict, total=False):
    """Arguments for UserCookies"""
    include: 'UserCookiesIncludeFromUserCookies'


class FindManyUserCookiesArgsFromUserCookies(TypedDict, total=False):
    """Arguments for UserCookies"""
    take: int
    skip: int
    order_by: Union['UserCookiesOrderByInput', List['UserCookiesOrderByInput']]
    where: 'UserCookiesWhereInput'
    cursor: 'UserCookiesWhereUniqueInput'
    distinct: List['UserCookiesScalarFieldKeys']
    include: 'UserCookiesIncludeFromUserCookies'


class NewsSourcesIncludeFromUserCookies(TypedDict, total=False):
    """Relational arguments for UserCookies"""
    rss: Union[bool, 'FindManyRssEntriesArgsFromUserCookies']
    articles: Union[bool, 'FindManyNewsArticlesArgsFromUserCookies']
    UsersArticles: Union[bool, 'FindManyUsersArticlesArgsFromUserCookies']


class NewsSourcesArgsFromUserCookies(TypedDict, total=False):
    """Arguments for UserCookies"""
    include: 'NewsSourcesIncludeFromNewsSources'


class FindManyNewsSourcesArgsFromUserCookies(TypedDict, total=False):
    """Arguments for UserCookies"""
    take: int
    skip: int
    order_by: Union['NewsSourcesOrderByInput', List['NewsSourcesOrderByInput']]
    where: 'NewsSourcesWhereInput'
    cursor: 'NewsSourcesWhereUniqueInput'
    distinct: List['NewsSourcesScalarFieldKeys']
    include: 'NewsSourcesIncludeFromNewsSources'


class RssEntriesIncludeFromUserCookies(TypedDict, total=False):
    """Relational arguments for UserCookies"""
    source: Union[bool, 'NewsSourcesArgsFromUserCookies']


class RssEntriesArgsFromUserCookies(TypedDict, total=False):
    """Arguments for UserCookies"""
    include: 'RssEntriesIncludeFromRssEntries'


class FindManyRssEntriesArgsFromUserCookies(TypedDict, total=False):
    """Arguments for UserCookies"""
    take: int
    skip: int
    order_by: Union['RssEntriesOrderByInput', List['RssEntriesOrderByInput']]
    where: 'RssEntriesWhereInput'
    cursor: 'RssEntriesWhereUniqueInput'
    distinct: List['RssEntriesScalarFieldKeys']
    include: 'RssEntriesIncludeFromRssEntries'


class NewsArticlesIncludeFromUserCookies(TypedDict, total=False):
    """Relational arguments for UserCookies"""
    source: Union[bool, 'NewsSourcesArgsFromUserCookies']
    labels: Union[bool, 'FindManyNewsArticleLabelsArgsFromUserCookies']
    similar_relation: Union[bool, 'FindManySimilarArticlesArgsFromUserCookies']
    similar_articles: Union[bool, 'FindManySimilarArticlesArgsFromUserCookies']
    UsersArticles: Union[bool, 'UsersArticlesArgsFromUserCookies']


class NewsArticlesArgsFromUserCookies(TypedDict, total=False):
    """Arguments for UserCookies"""
    include: 'NewsArticlesIncludeFromNewsArticles'


class FindManyNewsArticlesArgsFromUserCookies(TypedDict, total=False):
    """Arguments for UserCookies"""
    take: int
    skip: int
    order_by: Union['NewsArticlesOrderByInput', List['NewsArticlesOrderByInput']]
    where: 'NewsArticlesWhereInput'
    cursor: 'NewsArticlesWhereUniqueInput'
    distinct: List['NewsArticlesScalarFieldKeys']
    include: 'NewsArticlesIncludeFromNewsArticles'


class SimilarArticlesIncludeFromUserCookies(TypedDict, total=False):
    """Relational arguments for UserCookies"""
    article: Union[bool, 'NewsArticlesArgsFromUserCookies']
    similar: Union[bool, 'NewsArticlesArgsFromUserCookies']


class SimilarArticlesArgsFromUserCookies(TypedDict, total=False):
    """Arguments for UserCookies"""
    include: 'SimilarArticlesIncludeFromSimilarArticles'


class FindManySimilarArticlesArgsFromUserCookies(TypedDict, total=False):
    """Arguments for UserCookies"""
    take: int
    skip: int
    order_by: Union['SimilarArticlesOrderByInput', List['SimilarArticlesOrderByInput']]
    where: 'SimilarArticlesWhereInput'
    cursor: 'SimilarArticlesWhereUniqueInput'
    distinct: List['SimilarArticlesScalarFieldKeys']
    include: 'SimilarArticlesIncludeFromSimilarArticles'


class NewsArticleLabelsIncludeFromUserCookies(TypedDict, total=False):
    """Relational arguments for UserCookies"""
    article: Union[bool, 'NewsArticlesArgsFromUserCookies']


class NewsArticleLabelsArgsFromUserCookies(TypedDict, total=False):
    """Arguments for UserCookies"""
    include: 'NewsArticleLabelsIncludeFromNewsArticleLabels'


class FindManyNewsArticleLabelsArgsFromUserCookies(TypedDict, total=False):
    """Arguments for UserCookies"""
    take: int
    skip: int
    order_by: Union['NewsArticleLabelsOrderByInput', List['NewsArticleLabelsOrderByInput']]
    where: 'NewsArticleLabelsWhereInput'
    cursor: 'NewsArticleLabelsWhereUniqueInput'
    distinct: List['NewsArticleLabelsScalarFieldKeys']
    include: 'NewsArticleLabelsIncludeFromNewsArticleLabels'


class UsersArticlesIncludeFromUserCookies(TypedDict, total=False):
    """Relational arguments for UserCookies"""
    article: Union[bool, 'NewsArticlesArgsFromUserCookies']
    source: Union[bool, 'NewsSourcesArgsFromUserCookies']
    user: Union[bool, 'UsersArgsFromUserCookies']


class UsersArticlesArgsFromUserCookies(TypedDict, total=False):
    """Arguments for UserCookies"""
    include: 'UsersArticlesIncludeFromUsersArticles'


class FindManyUsersArticlesArgsFromUserCookies(TypedDict, total=False):
    """Arguments for UserCookies"""
    take: int
    skip: int
    order_by: Union['UsersArticlesOrderByInput', List['UsersArticlesOrderByInput']]
    where: 'UsersArticlesWhereInput'
    cursor: 'UsersArticlesWhereUniqueInput'
    distinct: List['UsersArticlesScalarFieldKeys']
    include: 'UsersArticlesIncludeFromUsersArticles'




FindManyUserCookiesArgs = FindManyUserCookiesArgsFromUserCookies
FindFirstUserCookiesArgs = FindManyUserCookiesArgsFromUserCookies


class UserCookiesWhereInput(TypedDict, total=False):
    """UserCookies arguments for searching"""
    user: 'UsersRelationFilter'
    user_id: Union[_int, 'types.IntFilter']
    cookie: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['UserCookiesWhereInput', List['UserCookiesWhereInput']]
    # but this causes mypy to hang :/
    AND: List['UserCookiesWhereInput']
    OR: List['UserCookiesWhereInput']
    NOT: List['UserCookiesWhereInput']



# aggregate UserCookies types


class UserCookiesScalarWhereWithAggregatesInput(TypedDict, total=False):
    """UserCookies arguments for searching"""
    user_id: Union[_int, 'types.IntWithAggregatesFilter']
    cookie: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['UserCookiesScalarWhereWithAggregatesInput']
    OR: List['UserCookiesScalarWhereWithAggregatesInput']
    NOT: List['UserCookiesScalarWhereWithAggregatesInput']



class UserCookiesGroupByOutput(TypedDict, total=False):
    user_id: _int
    cookie: _str
    _sum: 'UserCookiesSumAggregateOutput'
    _avg: 'UserCookiesAvgAggregateOutput'
    _min: 'UserCookiesMinAggregateOutput'
    _max: 'UserCookiesMaxAggregateOutput'
    _count: 'UserCookiesCountAggregateOutput'


class UserCookiesAvgAggregateOutput(TypedDict, total=False):
    """UserCookies output for aggregating averages"""
    user_id: float


class UserCookiesSumAggregateOutput(TypedDict, total=False):
    """UserCookies output for aggregating sums"""
    user_id: _int


class UserCookiesScalarAggregateOutput(TypedDict, total=False):
    """UserCookies output including scalar fields"""
    user_id: _int
    cookie: _str


UserCookiesMinAggregateOutput = UserCookiesScalarAggregateOutput
UserCookiesMaxAggregateOutput = UserCookiesScalarAggregateOutput


class UserCookiesMaxAggregateInput(TypedDict, total=False):
    """UserCookies input for aggregating by max"""
    user_id: bool
    cookie: bool


class UserCookiesMinAggregateInput(TypedDict, total=False):
    """UserCookies input for aggregating by min"""
    user_id: bool
    cookie: bool


class UserCookiesNumberAggregateInput(TypedDict, total=False):
    """UserCookies input for aggregating numbers"""
    user_id: bool


UserCookiesAvgAggregateInput = UserCookiesNumberAggregateInput
UserCookiesSumAggregateInput = UserCookiesNumberAggregateInput


UserCookiesCountAggregateInput = TypedDict(
    'UserCookiesCountAggregateInput',
    {
        'user_id': bool,
        'cookie': bool,
        '_all': bool,
    },
    total=False,
)

UserCookiesCountAggregateOutput = TypedDict(
    'UserCookiesCountAggregateOutput',
    {
        'user_id': int,
        'cookie': int,
        '_all': int,
    },
    total=False,
)


UserCookiesKeys = Literal[
    'user',
    'user_id',
    'cookie',
]
UserCookiesScalarFieldKeys = Literal[
    'user_id',
    'cookie',
]
UserCookiesScalarFieldKeysT = TypeVar('UserCookiesScalarFieldKeysT', bound=UserCookiesScalarFieldKeys)

UserCookiesRelationalFieldKeys = Literal[
        'user',
    ]

# NewsSources types

class NewsSourcesOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the NewsSources create method"""
    id: _int
    rss: 'RssEntriesCreateManyNestedWithoutRelationsInput'
    articles: 'NewsArticlesCreateManyNestedWithoutRelationsInput'
    UsersArticles: 'UsersArticlesCreateManyNestedWithoutRelationsInput'


class NewsSourcesCreateInput(NewsSourcesOptionalCreateInput):
    """Required arguments to the NewsSources create method"""
    name: _str
    url: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class NewsSourcesOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the NewsSources create method, without relations"""
    id: _int


class NewsSourcesCreateWithoutRelationsInput(NewsSourcesOptionalCreateWithoutRelationsInput):
    """Required arguments to the NewsSources create method, without relations"""
    name: _str
    url: _str


class NewsSourcesCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'NewsSourcesCreateWithoutRelationsInput'
    connect: 'NewsSourcesWhereUniqueInput'


class NewsSourcesCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['NewsSourcesCreateWithoutRelationsInput', List['NewsSourcesCreateWithoutRelationsInput']]
    connect: Union['NewsSourcesWhereUniqueInput', List['NewsSourcesWhereUniqueInput']]


_NewsSourcesWhereUnique_id_Input = TypedDict(
    '_NewsSourcesWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_NewsSourcesWhereUnique_name_Input = TypedDict(
    '_NewsSourcesWhereUnique_name_Input',
    {
        'name': '_str',
    },
    total=True
)

_NewsSourcesWhereUnique_url_Input = TypedDict(
    '_NewsSourcesWhereUnique_url_Input',
    {
        'url': '_str',
    },
    total=True
)

NewsSourcesWhereUniqueInput = Union[
    '_NewsSourcesWhereUnique_id_Input',
    '_NewsSourcesWhereUnique_name_Input',
    '_NewsSourcesWhereUnique_url_Input',
]


class NewsSourcesUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    name: _str
    url: _str
    rss: 'RssEntriesUpdateManyWithoutRelationsInput'
    articles: 'NewsArticlesUpdateManyWithoutRelationsInput'
    UsersArticles: 'UsersArticlesUpdateManyWithoutRelationsInput'


class NewsSourcesUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    name: _str
    url: _str


class NewsSourcesUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['NewsSourcesCreateWithoutRelationsInput']
    connect: List['NewsSourcesWhereUniqueInput']
    set: List['NewsSourcesWhereUniqueInput']
    disconnect: List['NewsSourcesWhereUniqueInput']
    delete: List['NewsSourcesWhereUniqueInput']

    # TODO
    # update: List['NewsSourcesUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['NewsSourcesUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['NewsSourcesScalarWhereInput']
    # upsert: List['NewsSourcesUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['NewsSourcesCreateOrConnectWithoutRelationsInput']


class NewsSourcesUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'NewsSourcesCreateWithoutRelationsInput'
    connect: 'NewsSourcesWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'NewsSourcesUpdateInput'
    # upsert: 'NewsSourcesUpsertWithoutRelationsInput'
    # connectOrCreate: 'NewsSourcesCreateOrConnectWithoutRelationsInput'


class NewsSourcesUpsertInput(TypedDict):
    create: 'NewsSourcesCreateInput'
    update: 'NewsSourcesUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_NewsSources_id_OrderByInput = TypedDict(
    '_NewsSources_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_NewsSources_name_OrderByInput = TypedDict(
    '_NewsSources_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_NewsSources_url_OrderByInput = TypedDict(
    '_NewsSources_url_OrderByInput',
    {
        'url': 'SortOrder',
    },
    total=True
)

NewsSourcesOrderByInput = Union[
    '_NewsSources_id_OrderByInput',
    '_NewsSources_name_OrderByInput',
    '_NewsSources_url_OrderByInput',
]



# recursive NewsSources types
# TODO: cleanup these types



NewsSourcesRelationFilter = TypedDict(
    'NewsSourcesRelationFilter',
    {
        'is': 'NewsSourcesWhereInput',
        'is_not': 'NewsSourcesWhereInput',
    },
    total=False,
)


class NewsSourcesListRelationFilter(TypedDict, total=False):
    some: 'NewsSourcesWhereInput'
    none: 'NewsSourcesWhereInput'
    every: 'NewsSourcesWhereInput'


class NewsSourcesInclude(TypedDict, total=False):
    """NewsSources relational arguments"""
    rss: Union[bool, 'FindManyRssEntriesArgsFromNewsSources']
    articles: Union[bool, 'FindManyNewsArticlesArgsFromNewsSources']
    UsersArticles: Union[bool, 'FindManyUsersArticlesArgsFromNewsSources']


class UsersIncludeFromNewsSources(TypedDict, total=False):
    """Relational arguments for NewsSources"""
    login: Union[bool, 'UserLoginsArgsFromNewsSources']
    cookies: Union[bool, 'FindManyUserCookiesArgsFromNewsSources']
    History: Union[bool, 'FindManyUsersArticlesArgsFromNewsSources']


class UsersArgsFromNewsSources(TypedDict, total=False):
    """Arguments for NewsSources"""
    include: 'UsersIncludeFromUsers'


class FindManyUsersArgsFromNewsSources(TypedDict, total=False):
    """Arguments for NewsSources"""
    take: int
    skip: int
    order_by: Union['UsersOrderByInput', List['UsersOrderByInput']]
    where: 'UsersWhereInput'
    cursor: 'UsersWhereUniqueInput'
    distinct: List['UsersScalarFieldKeys']
    include: 'UsersIncludeFromUsers'


class UserLoginsIncludeFromNewsSources(TypedDict, total=False):
    """Relational arguments for NewsSources"""
    user: Union[bool, 'UsersArgsFromNewsSources']


class UserLoginsArgsFromNewsSources(TypedDict, total=False):
    """Arguments for NewsSources"""
    include: 'UserLoginsIncludeFromUserLogins'


class FindManyUserLoginsArgsFromNewsSources(TypedDict, total=False):
    """Arguments for NewsSources"""
    take: int
    skip: int
    order_by: Union['UserLoginsOrderByInput', List['UserLoginsOrderByInput']]
    where: 'UserLoginsWhereInput'
    cursor: 'UserLoginsWhereUniqueInput'
    distinct: List['UserLoginsScalarFieldKeys']
    include: 'UserLoginsIncludeFromUserLogins'


class UserCookiesIncludeFromNewsSources(TypedDict, total=False):
    """Relational arguments for NewsSources"""
    user: Union[bool, 'UsersArgsFromNewsSources']


class UserCookiesArgsFromNewsSources(TypedDict, total=False):
    """Arguments for NewsSources"""
    include: 'UserCookiesIncludeFromUserCookies'


class FindManyUserCookiesArgsFromNewsSources(TypedDict, total=False):
    """Arguments for NewsSources"""
    take: int
    skip: int
    order_by: Union['UserCookiesOrderByInput', List['UserCookiesOrderByInput']]
    where: 'UserCookiesWhereInput'
    cursor: 'UserCookiesWhereUniqueInput'
    distinct: List['UserCookiesScalarFieldKeys']
    include: 'UserCookiesIncludeFromUserCookies'


class NewsSourcesIncludeFromNewsSources(TypedDict, total=False):
    """Relational arguments for NewsSources"""
    rss: Union[bool, 'FindManyRssEntriesArgsFromNewsSources']
    articles: Union[bool, 'FindManyNewsArticlesArgsFromNewsSources']
    UsersArticles: Union[bool, 'FindManyUsersArticlesArgsFromNewsSources']


class NewsSourcesArgsFromNewsSources(TypedDict, total=False):
    """Arguments for NewsSources"""
    include: 'NewsSourcesIncludeFromNewsSources'


class FindManyNewsSourcesArgsFromNewsSources(TypedDict, total=False):
    """Arguments for NewsSources"""
    take: int
    skip: int
    order_by: Union['NewsSourcesOrderByInput', List['NewsSourcesOrderByInput']]
    where: 'NewsSourcesWhereInput'
    cursor: 'NewsSourcesWhereUniqueInput'
    distinct: List['NewsSourcesScalarFieldKeys']
    include: 'NewsSourcesIncludeFromNewsSources'


class RssEntriesIncludeFromNewsSources(TypedDict, total=False):
    """Relational arguments for NewsSources"""
    source: Union[bool, 'NewsSourcesArgsFromNewsSources']


class RssEntriesArgsFromNewsSources(TypedDict, total=False):
    """Arguments for NewsSources"""
    include: 'RssEntriesIncludeFromRssEntries'


class FindManyRssEntriesArgsFromNewsSources(TypedDict, total=False):
    """Arguments for NewsSources"""
    take: int
    skip: int
    order_by: Union['RssEntriesOrderByInput', List['RssEntriesOrderByInput']]
    where: 'RssEntriesWhereInput'
    cursor: 'RssEntriesWhereUniqueInput'
    distinct: List['RssEntriesScalarFieldKeys']
    include: 'RssEntriesIncludeFromRssEntries'


class NewsArticlesIncludeFromNewsSources(TypedDict, total=False):
    """Relational arguments for NewsSources"""
    source: Union[bool, 'NewsSourcesArgsFromNewsSources']
    labels: Union[bool, 'FindManyNewsArticleLabelsArgsFromNewsSources']
    similar_relation: Union[bool, 'FindManySimilarArticlesArgsFromNewsSources']
    similar_articles: Union[bool, 'FindManySimilarArticlesArgsFromNewsSources']
    UsersArticles: Union[bool, 'UsersArticlesArgsFromNewsSources']


class NewsArticlesArgsFromNewsSources(TypedDict, total=False):
    """Arguments for NewsSources"""
    include: 'NewsArticlesIncludeFromNewsArticles'


class FindManyNewsArticlesArgsFromNewsSources(TypedDict, total=False):
    """Arguments for NewsSources"""
    take: int
    skip: int
    order_by: Union['NewsArticlesOrderByInput', List['NewsArticlesOrderByInput']]
    where: 'NewsArticlesWhereInput'
    cursor: 'NewsArticlesWhereUniqueInput'
    distinct: List['NewsArticlesScalarFieldKeys']
    include: 'NewsArticlesIncludeFromNewsArticles'


class SimilarArticlesIncludeFromNewsSources(TypedDict, total=False):
    """Relational arguments for NewsSources"""
    article: Union[bool, 'NewsArticlesArgsFromNewsSources']
    similar: Union[bool, 'NewsArticlesArgsFromNewsSources']


class SimilarArticlesArgsFromNewsSources(TypedDict, total=False):
    """Arguments for NewsSources"""
    include: 'SimilarArticlesIncludeFromSimilarArticles'


class FindManySimilarArticlesArgsFromNewsSources(TypedDict, total=False):
    """Arguments for NewsSources"""
    take: int
    skip: int
    order_by: Union['SimilarArticlesOrderByInput', List['SimilarArticlesOrderByInput']]
    where: 'SimilarArticlesWhereInput'
    cursor: 'SimilarArticlesWhereUniqueInput'
    distinct: List['SimilarArticlesScalarFieldKeys']
    include: 'SimilarArticlesIncludeFromSimilarArticles'


class NewsArticleLabelsIncludeFromNewsSources(TypedDict, total=False):
    """Relational arguments for NewsSources"""
    article: Union[bool, 'NewsArticlesArgsFromNewsSources']


class NewsArticleLabelsArgsFromNewsSources(TypedDict, total=False):
    """Arguments for NewsSources"""
    include: 'NewsArticleLabelsIncludeFromNewsArticleLabels'


class FindManyNewsArticleLabelsArgsFromNewsSources(TypedDict, total=False):
    """Arguments for NewsSources"""
    take: int
    skip: int
    order_by: Union['NewsArticleLabelsOrderByInput', List['NewsArticleLabelsOrderByInput']]
    where: 'NewsArticleLabelsWhereInput'
    cursor: 'NewsArticleLabelsWhereUniqueInput'
    distinct: List['NewsArticleLabelsScalarFieldKeys']
    include: 'NewsArticleLabelsIncludeFromNewsArticleLabels'


class UsersArticlesIncludeFromNewsSources(TypedDict, total=False):
    """Relational arguments for NewsSources"""
    article: Union[bool, 'NewsArticlesArgsFromNewsSources']
    source: Union[bool, 'NewsSourcesArgsFromNewsSources']
    user: Union[bool, 'UsersArgsFromNewsSources']


class UsersArticlesArgsFromNewsSources(TypedDict, total=False):
    """Arguments for NewsSources"""
    include: 'UsersArticlesIncludeFromUsersArticles'


class FindManyUsersArticlesArgsFromNewsSources(TypedDict, total=False):
    """Arguments for NewsSources"""
    take: int
    skip: int
    order_by: Union['UsersArticlesOrderByInput', List['UsersArticlesOrderByInput']]
    where: 'UsersArticlesWhereInput'
    cursor: 'UsersArticlesWhereUniqueInput'
    distinct: List['UsersArticlesScalarFieldKeys']
    include: 'UsersArticlesIncludeFromUsersArticles'




FindManyNewsSourcesArgs = FindManyNewsSourcesArgsFromNewsSources
FindFirstNewsSourcesArgs = FindManyNewsSourcesArgsFromNewsSources


class NewsSourcesWhereInput(TypedDict, total=False):
    """NewsSources arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    url: Union[_str, 'types.StringFilter']
    rss: 'RssEntriesListRelationFilter'
    articles: 'NewsArticlesListRelationFilter'
    UsersArticles: 'UsersArticlesListRelationFilter'

    # should be noted that AND and NOT should be Union['NewsSourcesWhereInput', List['NewsSourcesWhereInput']]
    # but this causes mypy to hang :/
    AND: List['NewsSourcesWhereInput']
    OR: List['NewsSourcesWhereInput']
    NOT: List['NewsSourcesWhereInput']



# aggregate NewsSources types


class NewsSourcesScalarWhereWithAggregatesInput(TypedDict, total=False):
    """NewsSources arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    url: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['NewsSourcesScalarWhereWithAggregatesInput']
    OR: List['NewsSourcesScalarWhereWithAggregatesInput']
    NOT: List['NewsSourcesScalarWhereWithAggregatesInput']



class NewsSourcesGroupByOutput(TypedDict, total=False):
    id: _int
    name: _str
    url: _str
    _sum: 'NewsSourcesSumAggregateOutput'
    _avg: 'NewsSourcesAvgAggregateOutput'
    _min: 'NewsSourcesMinAggregateOutput'
    _max: 'NewsSourcesMaxAggregateOutput'
    _count: 'NewsSourcesCountAggregateOutput'


class NewsSourcesAvgAggregateOutput(TypedDict, total=False):
    """NewsSources output for aggregating averages"""
    id: float


class NewsSourcesSumAggregateOutput(TypedDict, total=False):
    """NewsSources output for aggregating sums"""
    id: _int


class NewsSourcesScalarAggregateOutput(TypedDict, total=False):
    """NewsSources output including scalar fields"""
    id: _int
    name: _str
    url: _str


NewsSourcesMinAggregateOutput = NewsSourcesScalarAggregateOutput
NewsSourcesMaxAggregateOutput = NewsSourcesScalarAggregateOutput


class NewsSourcesMaxAggregateInput(TypedDict, total=False):
    """NewsSources input for aggregating by max"""
    id: bool
    name: bool
    url: bool


class NewsSourcesMinAggregateInput(TypedDict, total=False):
    """NewsSources input for aggregating by min"""
    id: bool
    name: bool
    url: bool


class NewsSourcesNumberAggregateInput(TypedDict, total=False):
    """NewsSources input for aggregating numbers"""
    id: bool


NewsSourcesAvgAggregateInput = NewsSourcesNumberAggregateInput
NewsSourcesSumAggregateInput = NewsSourcesNumberAggregateInput


NewsSourcesCountAggregateInput = TypedDict(
    'NewsSourcesCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'url': bool,
        '_all': bool,
    },
    total=False,
)

NewsSourcesCountAggregateOutput = TypedDict(
    'NewsSourcesCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'url': int,
        '_all': int,
    },
    total=False,
)


NewsSourcesKeys = Literal[
    'id',
    'name',
    'url',
    'rss',
    'articles',
    'UsersArticles',
]
NewsSourcesScalarFieldKeys = Literal[
    'id',
    'name',
    'url',
]
NewsSourcesScalarFieldKeysT = TypeVar('NewsSourcesScalarFieldKeysT', bound=NewsSourcesScalarFieldKeys)

NewsSourcesRelationalFieldKeys = Literal[
        'rss',
        'articles',
        'UsersArticles',
    ]

# RssEntries types

class RssEntriesOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the RssEntries create method"""
    source: 'NewsSourcesCreateNestedWithoutRelationsInput'
    source_id: _int


class RssEntriesCreateInput(RssEntriesOptionalCreateInput):
    """Required arguments to the RssEntries create method"""
    feed: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class RssEntriesOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the RssEntries create method, without relations"""
    source_id: _int


class RssEntriesCreateWithoutRelationsInput(RssEntriesOptionalCreateWithoutRelationsInput):
    """Required arguments to the RssEntries create method, without relations"""
    feed: _str


class RssEntriesCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'RssEntriesCreateWithoutRelationsInput'
    connect: 'RssEntriesWhereUniqueInput'


class RssEntriesCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['RssEntriesCreateWithoutRelationsInput', List['RssEntriesCreateWithoutRelationsInput']]
    connect: Union['RssEntriesWhereUniqueInput', List['RssEntriesWhereUniqueInput']]


_RssEntriesWhereUnique_feed_Input = TypedDict(
    '_RssEntriesWhereUnique_feed_Input',
    {
        'feed': '_str',
    },
    total=True
)

RssEntriesWhereUniqueInput = _RssEntriesWhereUnique_feed_Input


class RssEntriesUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    source: 'NewsSourcesUpdateOneWithoutRelationsInput'
    feed: _str


class RssEntriesUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    feed: _str


class RssEntriesUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['RssEntriesCreateWithoutRelationsInput']
    connect: List['RssEntriesWhereUniqueInput']
    set: List['RssEntriesWhereUniqueInput']
    disconnect: List['RssEntriesWhereUniqueInput']
    delete: List['RssEntriesWhereUniqueInput']

    # TODO
    # update: List['RssEntriesUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['RssEntriesUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['RssEntriesScalarWhereInput']
    # upsert: List['RssEntriesUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['RssEntriesCreateOrConnectWithoutRelationsInput']


class RssEntriesUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'RssEntriesCreateWithoutRelationsInput'
    connect: 'RssEntriesWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'RssEntriesUpdateInput'
    # upsert: 'RssEntriesUpsertWithoutRelationsInput'
    # connectOrCreate: 'RssEntriesCreateOrConnectWithoutRelationsInput'


class RssEntriesUpsertInput(TypedDict):
    create: 'RssEntriesCreateInput'
    update: 'RssEntriesUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_RssEntries_source_id_OrderByInput = TypedDict(
    '_RssEntries_source_id_OrderByInput',
    {
        'source_id': 'SortOrder',
    },
    total=True
)

_RssEntries_feed_OrderByInput = TypedDict(
    '_RssEntries_feed_OrderByInput',
    {
        'feed': 'SortOrder',
    },
    total=True
)

RssEntriesOrderByInput = Union[
    '_RssEntries_source_id_OrderByInput',
    '_RssEntries_feed_OrderByInput',
]



# recursive RssEntries types
# TODO: cleanup these types



RssEntriesRelationFilter = TypedDict(
    'RssEntriesRelationFilter',
    {
        'is': 'RssEntriesWhereInput',
        'is_not': 'RssEntriesWhereInput',
    },
    total=False,
)


class RssEntriesListRelationFilter(TypedDict, total=False):
    some: 'RssEntriesWhereInput'
    none: 'RssEntriesWhereInput'
    every: 'RssEntriesWhereInput'


class RssEntriesInclude(TypedDict, total=False):
    """RssEntries relational arguments"""
    source: Union[bool, 'NewsSourcesArgsFromRssEntries']


class UsersIncludeFromRssEntries(TypedDict, total=False):
    """Relational arguments for RssEntries"""
    login: Union[bool, 'UserLoginsArgsFromRssEntries']
    cookies: Union[bool, 'FindManyUserCookiesArgsFromRssEntries']
    History: Union[bool, 'FindManyUsersArticlesArgsFromRssEntries']


class UsersArgsFromRssEntries(TypedDict, total=False):
    """Arguments for RssEntries"""
    include: 'UsersIncludeFromUsers'


class FindManyUsersArgsFromRssEntries(TypedDict, total=False):
    """Arguments for RssEntries"""
    take: int
    skip: int
    order_by: Union['UsersOrderByInput', List['UsersOrderByInput']]
    where: 'UsersWhereInput'
    cursor: 'UsersWhereUniqueInput'
    distinct: List['UsersScalarFieldKeys']
    include: 'UsersIncludeFromUsers'


class UserLoginsIncludeFromRssEntries(TypedDict, total=False):
    """Relational arguments for RssEntries"""
    user: Union[bool, 'UsersArgsFromRssEntries']


class UserLoginsArgsFromRssEntries(TypedDict, total=False):
    """Arguments for RssEntries"""
    include: 'UserLoginsIncludeFromUserLogins'


class FindManyUserLoginsArgsFromRssEntries(TypedDict, total=False):
    """Arguments for RssEntries"""
    take: int
    skip: int
    order_by: Union['UserLoginsOrderByInput', List['UserLoginsOrderByInput']]
    where: 'UserLoginsWhereInput'
    cursor: 'UserLoginsWhereUniqueInput'
    distinct: List['UserLoginsScalarFieldKeys']
    include: 'UserLoginsIncludeFromUserLogins'


class UserCookiesIncludeFromRssEntries(TypedDict, total=False):
    """Relational arguments for RssEntries"""
    user: Union[bool, 'UsersArgsFromRssEntries']


class UserCookiesArgsFromRssEntries(TypedDict, total=False):
    """Arguments for RssEntries"""
    include: 'UserCookiesIncludeFromUserCookies'


class FindManyUserCookiesArgsFromRssEntries(TypedDict, total=False):
    """Arguments for RssEntries"""
    take: int
    skip: int
    order_by: Union['UserCookiesOrderByInput', List['UserCookiesOrderByInput']]
    where: 'UserCookiesWhereInput'
    cursor: 'UserCookiesWhereUniqueInput'
    distinct: List['UserCookiesScalarFieldKeys']
    include: 'UserCookiesIncludeFromUserCookies'


class NewsSourcesIncludeFromRssEntries(TypedDict, total=False):
    """Relational arguments for RssEntries"""
    rss: Union[bool, 'FindManyRssEntriesArgsFromRssEntries']
    articles: Union[bool, 'FindManyNewsArticlesArgsFromRssEntries']
    UsersArticles: Union[bool, 'FindManyUsersArticlesArgsFromRssEntries']


class NewsSourcesArgsFromRssEntries(TypedDict, total=False):
    """Arguments for RssEntries"""
    include: 'NewsSourcesIncludeFromNewsSources'


class FindManyNewsSourcesArgsFromRssEntries(TypedDict, total=False):
    """Arguments for RssEntries"""
    take: int
    skip: int
    order_by: Union['NewsSourcesOrderByInput', List['NewsSourcesOrderByInput']]
    where: 'NewsSourcesWhereInput'
    cursor: 'NewsSourcesWhereUniqueInput'
    distinct: List['NewsSourcesScalarFieldKeys']
    include: 'NewsSourcesIncludeFromNewsSources'


class RssEntriesIncludeFromRssEntries(TypedDict, total=False):
    """Relational arguments for RssEntries"""
    source: Union[bool, 'NewsSourcesArgsFromRssEntries']


class RssEntriesArgsFromRssEntries(TypedDict, total=False):
    """Arguments for RssEntries"""
    include: 'RssEntriesIncludeFromRssEntries'


class FindManyRssEntriesArgsFromRssEntries(TypedDict, total=False):
    """Arguments for RssEntries"""
    take: int
    skip: int
    order_by: Union['RssEntriesOrderByInput', List['RssEntriesOrderByInput']]
    where: 'RssEntriesWhereInput'
    cursor: 'RssEntriesWhereUniqueInput'
    distinct: List['RssEntriesScalarFieldKeys']
    include: 'RssEntriesIncludeFromRssEntries'


class NewsArticlesIncludeFromRssEntries(TypedDict, total=False):
    """Relational arguments for RssEntries"""
    source: Union[bool, 'NewsSourcesArgsFromRssEntries']
    labels: Union[bool, 'FindManyNewsArticleLabelsArgsFromRssEntries']
    similar_relation: Union[bool, 'FindManySimilarArticlesArgsFromRssEntries']
    similar_articles: Union[bool, 'FindManySimilarArticlesArgsFromRssEntries']
    UsersArticles: Union[bool, 'UsersArticlesArgsFromRssEntries']


class NewsArticlesArgsFromRssEntries(TypedDict, total=False):
    """Arguments for RssEntries"""
    include: 'NewsArticlesIncludeFromNewsArticles'


class FindManyNewsArticlesArgsFromRssEntries(TypedDict, total=False):
    """Arguments for RssEntries"""
    take: int
    skip: int
    order_by: Union['NewsArticlesOrderByInput', List['NewsArticlesOrderByInput']]
    where: 'NewsArticlesWhereInput'
    cursor: 'NewsArticlesWhereUniqueInput'
    distinct: List['NewsArticlesScalarFieldKeys']
    include: 'NewsArticlesIncludeFromNewsArticles'


class SimilarArticlesIncludeFromRssEntries(TypedDict, total=False):
    """Relational arguments for RssEntries"""
    article: Union[bool, 'NewsArticlesArgsFromRssEntries']
    similar: Union[bool, 'NewsArticlesArgsFromRssEntries']


class SimilarArticlesArgsFromRssEntries(TypedDict, total=False):
    """Arguments for RssEntries"""
    include: 'SimilarArticlesIncludeFromSimilarArticles'


class FindManySimilarArticlesArgsFromRssEntries(TypedDict, total=False):
    """Arguments for RssEntries"""
    take: int
    skip: int
    order_by: Union['SimilarArticlesOrderByInput', List['SimilarArticlesOrderByInput']]
    where: 'SimilarArticlesWhereInput'
    cursor: 'SimilarArticlesWhereUniqueInput'
    distinct: List['SimilarArticlesScalarFieldKeys']
    include: 'SimilarArticlesIncludeFromSimilarArticles'


class NewsArticleLabelsIncludeFromRssEntries(TypedDict, total=False):
    """Relational arguments for RssEntries"""
    article: Union[bool, 'NewsArticlesArgsFromRssEntries']


class NewsArticleLabelsArgsFromRssEntries(TypedDict, total=False):
    """Arguments for RssEntries"""
    include: 'NewsArticleLabelsIncludeFromNewsArticleLabels'


class FindManyNewsArticleLabelsArgsFromRssEntries(TypedDict, total=False):
    """Arguments for RssEntries"""
    take: int
    skip: int
    order_by: Union['NewsArticleLabelsOrderByInput', List['NewsArticleLabelsOrderByInput']]
    where: 'NewsArticleLabelsWhereInput'
    cursor: 'NewsArticleLabelsWhereUniqueInput'
    distinct: List['NewsArticleLabelsScalarFieldKeys']
    include: 'NewsArticleLabelsIncludeFromNewsArticleLabels'


class UsersArticlesIncludeFromRssEntries(TypedDict, total=False):
    """Relational arguments for RssEntries"""
    article: Union[bool, 'NewsArticlesArgsFromRssEntries']
    source: Union[bool, 'NewsSourcesArgsFromRssEntries']
    user: Union[bool, 'UsersArgsFromRssEntries']


class UsersArticlesArgsFromRssEntries(TypedDict, total=False):
    """Arguments for RssEntries"""
    include: 'UsersArticlesIncludeFromUsersArticles'


class FindManyUsersArticlesArgsFromRssEntries(TypedDict, total=False):
    """Arguments for RssEntries"""
    take: int
    skip: int
    order_by: Union['UsersArticlesOrderByInput', List['UsersArticlesOrderByInput']]
    where: 'UsersArticlesWhereInput'
    cursor: 'UsersArticlesWhereUniqueInput'
    distinct: List['UsersArticlesScalarFieldKeys']
    include: 'UsersArticlesIncludeFromUsersArticles'




FindManyRssEntriesArgs = FindManyRssEntriesArgsFromRssEntries
FindFirstRssEntriesArgs = FindManyRssEntriesArgsFromRssEntries


class RssEntriesWhereInput(TypedDict, total=False):
    """RssEntries arguments for searching"""
    source: 'NewsSourcesRelationFilter'
    source_id: Union[_int, 'types.IntFilter']
    feed: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['RssEntriesWhereInput', List['RssEntriesWhereInput']]
    # but this causes mypy to hang :/
    AND: List['RssEntriesWhereInput']
    OR: List['RssEntriesWhereInput']
    NOT: List['RssEntriesWhereInput']



# aggregate RssEntries types


class RssEntriesScalarWhereWithAggregatesInput(TypedDict, total=False):
    """RssEntries arguments for searching"""
    source_id: Union[_int, 'types.IntWithAggregatesFilter']
    feed: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['RssEntriesScalarWhereWithAggregatesInput']
    OR: List['RssEntriesScalarWhereWithAggregatesInput']
    NOT: List['RssEntriesScalarWhereWithAggregatesInput']



class RssEntriesGroupByOutput(TypedDict, total=False):
    source_id: _int
    feed: _str
    _sum: 'RssEntriesSumAggregateOutput'
    _avg: 'RssEntriesAvgAggregateOutput'
    _min: 'RssEntriesMinAggregateOutput'
    _max: 'RssEntriesMaxAggregateOutput'
    _count: 'RssEntriesCountAggregateOutput'


class RssEntriesAvgAggregateOutput(TypedDict, total=False):
    """RssEntries output for aggregating averages"""
    source_id: float


class RssEntriesSumAggregateOutput(TypedDict, total=False):
    """RssEntries output for aggregating sums"""
    source_id: _int


class RssEntriesScalarAggregateOutput(TypedDict, total=False):
    """RssEntries output including scalar fields"""
    source_id: _int
    feed: _str


RssEntriesMinAggregateOutput = RssEntriesScalarAggregateOutput
RssEntriesMaxAggregateOutput = RssEntriesScalarAggregateOutput


class RssEntriesMaxAggregateInput(TypedDict, total=False):
    """RssEntries input for aggregating by max"""
    source_id: bool
    feed: bool


class RssEntriesMinAggregateInput(TypedDict, total=False):
    """RssEntries input for aggregating by min"""
    source_id: bool
    feed: bool


class RssEntriesNumberAggregateInput(TypedDict, total=False):
    """RssEntries input for aggregating numbers"""
    source_id: bool


RssEntriesAvgAggregateInput = RssEntriesNumberAggregateInput
RssEntriesSumAggregateInput = RssEntriesNumberAggregateInput


RssEntriesCountAggregateInput = TypedDict(
    'RssEntriesCountAggregateInput',
    {
        'source_id': bool,
        'feed': bool,
        '_all': bool,
    },
    total=False,
)

RssEntriesCountAggregateOutput = TypedDict(
    'RssEntriesCountAggregateOutput',
    {
        'source_id': int,
        'feed': int,
        '_all': int,
    },
    total=False,
)


RssEntriesKeys = Literal[
    'source',
    'source_id',
    'feed',
]
RssEntriesScalarFieldKeys = Literal[
    'source_id',
    'feed',
]
RssEntriesScalarFieldKeysT = TypeVar('RssEntriesScalarFieldKeysT', bound=RssEntriesScalarFieldKeys)

RssEntriesRelationalFieldKeys = Literal[
        'source',
    ]

# NewsArticles types

class NewsArticlesOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the NewsArticles create method"""
    id: _int
    source: 'NewsSourcesCreateNestedWithoutRelationsInput'
    source_id: _int
    description: Optional[_str]
    photo: Optional[_str]
    publication_date: Optional[datetime.datetime]
    labels: 'NewsArticleLabelsCreateManyNestedWithoutRelationsInput'
    similar_relation: 'SimilarArticlesCreateManyNestedWithoutRelationsInput'
    similar_articles: 'SimilarArticlesCreateManyNestedWithoutRelationsInput'
    UsersArticles: 'UsersArticlesCreateNestedWithoutRelationsInput'


class NewsArticlesCreateInput(NewsArticlesOptionalCreateInput):
    """Required arguments to the NewsArticles create method"""
    url: _str
    title: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class NewsArticlesOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the NewsArticles create method, without relations"""
    id: _int
    source_id: _int
    description: Optional[_str]
    photo: Optional[_str]
    publication_date: Optional[datetime.datetime]


class NewsArticlesCreateWithoutRelationsInput(NewsArticlesOptionalCreateWithoutRelationsInput):
    """Required arguments to the NewsArticles create method, without relations"""
    url: _str
    title: _str


class NewsArticlesCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'NewsArticlesCreateWithoutRelationsInput'
    connect: 'NewsArticlesWhereUniqueInput'


class NewsArticlesCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['NewsArticlesCreateWithoutRelationsInput', List['NewsArticlesCreateWithoutRelationsInput']]
    connect: Union['NewsArticlesWhereUniqueInput', List['NewsArticlesWhereUniqueInput']]


_NewsArticlesWhereUnique_id_Input = TypedDict(
    '_NewsArticlesWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_NewsArticlesWhereUnique_url_Input = TypedDict(
    '_NewsArticlesWhereUnique_url_Input',
    {
        'url': '_str',
    },
    total=True
)

_NewsArticlesCompoundid_urlKeyInner = TypedDict(
    '_NewsArticlesCompoundid_urlKeyInner',
    {
        'id': '_int',
        'url': '_str',
    },
    total=True
)

_NewsArticlesCompoundid_urlKey = TypedDict(
    '_NewsArticlesCompoundid_urlKey',
    {
        'id_url': '_NewsArticlesCompoundid_urlKeyInner',
    },
    total=True
)

NewsArticlesWhereUniqueInput = Union[
    '_NewsArticlesWhereUnique_id_Input',
    '_NewsArticlesWhereUnique_url_Input',
    '_NewsArticlesCompoundid_urlKey',
]


class NewsArticlesUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    source: 'NewsSourcesUpdateOneWithoutRelationsInput'
    url: _str
    title: _str
    description: Optional[_str]
    photo: Optional[_str]
    publication_date: Optional[datetime.datetime]
    labels: 'NewsArticleLabelsUpdateManyWithoutRelationsInput'
    similar_relation: 'SimilarArticlesUpdateManyWithoutRelationsInput'
    similar_articles: 'SimilarArticlesUpdateManyWithoutRelationsInput'
    UsersArticles: 'UsersArticlesUpdateOneWithoutRelationsInput'


class NewsArticlesUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    url: _str
    title: _str
    description: Optional[_str]
    photo: Optional[_str]
    publication_date: Optional[datetime.datetime]


class NewsArticlesUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['NewsArticlesCreateWithoutRelationsInput']
    connect: List['NewsArticlesWhereUniqueInput']
    set: List['NewsArticlesWhereUniqueInput']
    disconnect: List['NewsArticlesWhereUniqueInput']
    delete: List['NewsArticlesWhereUniqueInput']

    # TODO
    # update: List['NewsArticlesUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['NewsArticlesUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['NewsArticlesScalarWhereInput']
    # upsert: List['NewsArticlesUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['NewsArticlesCreateOrConnectWithoutRelationsInput']


class NewsArticlesUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'NewsArticlesCreateWithoutRelationsInput'
    connect: 'NewsArticlesWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'NewsArticlesUpdateInput'
    # upsert: 'NewsArticlesUpsertWithoutRelationsInput'
    # connectOrCreate: 'NewsArticlesCreateOrConnectWithoutRelationsInput'


class NewsArticlesUpsertInput(TypedDict):
    create: 'NewsArticlesCreateInput'
    update: 'NewsArticlesUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_NewsArticles_id_OrderByInput = TypedDict(
    '_NewsArticles_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_NewsArticles_source_id_OrderByInput = TypedDict(
    '_NewsArticles_source_id_OrderByInput',
    {
        'source_id': 'SortOrder',
    },
    total=True
)

_NewsArticles_url_OrderByInput = TypedDict(
    '_NewsArticles_url_OrderByInput',
    {
        'url': 'SortOrder',
    },
    total=True
)

_NewsArticles_title_OrderByInput = TypedDict(
    '_NewsArticles_title_OrderByInput',
    {
        'title': 'SortOrder',
    },
    total=True
)

_NewsArticles_description_OrderByInput = TypedDict(
    '_NewsArticles_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_NewsArticles_photo_OrderByInput = TypedDict(
    '_NewsArticles_photo_OrderByInput',
    {
        'photo': 'SortOrder',
    },
    total=True
)

_NewsArticles_publication_date_OrderByInput = TypedDict(
    '_NewsArticles_publication_date_OrderByInput',
    {
        'publication_date': 'SortOrder',
    },
    total=True
)

NewsArticlesOrderByInput = Union[
    '_NewsArticles_id_OrderByInput',
    '_NewsArticles_source_id_OrderByInput',
    '_NewsArticles_url_OrderByInput',
    '_NewsArticles_title_OrderByInput',
    '_NewsArticles_description_OrderByInput',
    '_NewsArticles_photo_OrderByInput',
    '_NewsArticles_publication_date_OrderByInput',
]



# recursive NewsArticles types
# TODO: cleanup these types



NewsArticlesRelationFilter = TypedDict(
    'NewsArticlesRelationFilter',
    {
        'is': 'NewsArticlesWhereInput',
        'is_not': 'NewsArticlesWhereInput',
    },
    total=False,
)


class NewsArticlesListRelationFilter(TypedDict, total=False):
    some: 'NewsArticlesWhereInput'
    none: 'NewsArticlesWhereInput'
    every: 'NewsArticlesWhereInput'


class NewsArticlesInclude(TypedDict, total=False):
    """NewsArticles relational arguments"""
    source: Union[bool, 'NewsSourcesArgsFromNewsArticles']
    labels: Union[bool, 'FindManyNewsArticleLabelsArgsFromNewsArticles']
    similar_relation: Union[bool, 'FindManySimilarArticlesArgsFromNewsArticles']
    similar_articles: Union[bool, 'FindManySimilarArticlesArgsFromNewsArticles']
    UsersArticles: Union[bool, 'UsersArticlesArgsFromNewsArticles']


class UsersIncludeFromNewsArticles(TypedDict, total=False):
    """Relational arguments for NewsArticles"""
    login: Union[bool, 'UserLoginsArgsFromNewsArticles']
    cookies: Union[bool, 'FindManyUserCookiesArgsFromNewsArticles']
    History: Union[bool, 'FindManyUsersArticlesArgsFromNewsArticles']


class UsersArgsFromNewsArticles(TypedDict, total=False):
    """Arguments for NewsArticles"""
    include: 'UsersIncludeFromUsers'


class FindManyUsersArgsFromNewsArticles(TypedDict, total=False):
    """Arguments for NewsArticles"""
    take: int
    skip: int
    order_by: Union['UsersOrderByInput', List['UsersOrderByInput']]
    where: 'UsersWhereInput'
    cursor: 'UsersWhereUniqueInput'
    distinct: List['UsersScalarFieldKeys']
    include: 'UsersIncludeFromUsers'


class UserLoginsIncludeFromNewsArticles(TypedDict, total=False):
    """Relational arguments for NewsArticles"""
    user: Union[bool, 'UsersArgsFromNewsArticles']


class UserLoginsArgsFromNewsArticles(TypedDict, total=False):
    """Arguments for NewsArticles"""
    include: 'UserLoginsIncludeFromUserLogins'


class FindManyUserLoginsArgsFromNewsArticles(TypedDict, total=False):
    """Arguments for NewsArticles"""
    take: int
    skip: int
    order_by: Union['UserLoginsOrderByInput', List['UserLoginsOrderByInput']]
    where: 'UserLoginsWhereInput'
    cursor: 'UserLoginsWhereUniqueInput'
    distinct: List['UserLoginsScalarFieldKeys']
    include: 'UserLoginsIncludeFromUserLogins'


class UserCookiesIncludeFromNewsArticles(TypedDict, total=False):
    """Relational arguments for NewsArticles"""
    user: Union[bool, 'UsersArgsFromNewsArticles']


class UserCookiesArgsFromNewsArticles(TypedDict, total=False):
    """Arguments for NewsArticles"""
    include: 'UserCookiesIncludeFromUserCookies'


class FindManyUserCookiesArgsFromNewsArticles(TypedDict, total=False):
    """Arguments for NewsArticles"""
    take: int
    skip: int
    order_by: Union['UserCookiesOrderByInput', List['UserCookiesOrderByInput']]
    where: 'UserCookiesWhereInput'
    cursor: 'UserCookiesWhereUniqueInput'
    distinct: List['UserCookiesScalarFieldKeys']
    include: 'UserCookiesIncludeFromUserCookies'


class NewsSourcesIncludeFromNewsArticles(TypedDict, total=False):
    """Relational arguments for NewsArticles"""
    rss: Union[bool, 'FindManyRssEntriesArgsFromNewsArticles']
    articles: Union[bool, 'FindManyNewsArticlesArgsFromNewsArticles']
    UsersArticles: Union[bool, 'FindManyUsersArticlesArgsFromNewsArticles']


class NewsSourcesArgsFromNewsArticles(TypedDict, total=False):
    """Arguments for NewsArticles"""
    include: 'NewsSourcesIncludeFromNewsSources'


class FindManyNewsSourcesArgsFromNewsArticles(TypedDict, total=False):
    """Arguments for NewsArticles"""
    take: int
    skip: int
    order_by: Union['NewsSourcesOrderByInput', List['NewsSourcesOrderByInput']]
    where: 'NewsSourcesWhereInput'
    cursor: 'NewsSourcesWhereUniqueInput'
    distinct: List['NewsSourcesScalarFieldKeys']
    include: 'NewsSourcesIncludeFromNewsSources'


class RssEntriesIncludeFromNewsArticles(TypedDict, total=False):
    """Relational arguments for NewsArticles"""
    source: Union[bool, 'NewsSourcesArgsFromNewsArticles']


class RssEntriesArgsFromNewsArticles(TypedDict, total=False):
    """Arguments for NewsArticles"""
    include: 'RssEntriesIncludeFromRssEntries'


class FindManyRssEntriesArgsFromNewsArticles(TypedDict, total=False):
    """Arguments for NewsArticles"""
    take: int
    skip: int
    order_by: Union['RssEntriesOrderByInput', List['RssEntriesOrderByInput']]
    where: 'RssEntriesWhereInput'
    cursor: 'RssEntriesWhereUniqueInput'
    distinct: List['RssEntriesScalarFieldKeys']
    include: 'RssEntriesIncludeFromRssEntries'


class NewsArticlesIncludeFromNewsArticles(TypedDict, total=False):
    """Relational arguments for NewsArticles"""
    source: Union[bool, 'NewsSourcesArgsFromNewsArticles']
    labels: Union[bool, 'FindManyNewsArticleLabelsArgsFromNewsArticles']
    similar_relation: Union[bool, 'FindManySimilarArticlesArgsFromNewsArticles']
    similar_articles: Union[bool, 'FindManySimilarArticlesArgsFromNewsArticles']
    UsersArticles: Union[bool, 'UsersArticlesArgsFromNewsArticles']


class NewsArticlesArgsFromNewsArticles(TypedDict, total=False):
    """Arguments for NewsArticles"""
    include: 'NewsArticlesIncludeFromNewsArticles'


class FindManyNewsArticlesArgsFromNewsArticles(TypedDict, total=False):
    """Arguments for NewsArticles"""
    take: int
    skip: int
    order_by: Union['NewsArticlesOrderByInput', List['NewsArticlesOrderByInput']]
    where: 'NewsArticlesWhereInput'
    cursor: 'NewsArticlesWhereUniqueInput'
    distinct: List['NewsArticlesScalarFieldKeys']
    include: 'NewsArticlesIncludeFromNewsArticles'


class SimilarArticlesIncludeFromNewsArticles(TypedDict, total=False):
    """Relational arguments for NewsArticles"""
    article: Union[bool, 'NewsArticlesArgsFromNewsArticles']
    similar: Union[bool, 'NewsArticlesArgsFromNewsArticles']


class SimilarArticlesArgsFromNewsArticles(TypedDict, total=False):
    """Arguments for NewsArticles"""
    include: 'SimilarArticlesIncludeFromSimilarArticles'


class FindManySimilarArticlesArgsFromNewsArticles(TypedDict, total=False):
    """Arguments for NewsArticles"""
    take: int
    skip: int
    order_by: Union['SimilarArticlesOrderByInput', List['SimilarArticlesOrderByInput']]
    where: 'SimilarArticlesWhereInput'
    cursor: 'SimilarArticlesWhereUniqueInput'
    distinct: List['SimilarArticlesScalarFieldKeys']
    include: 'SimilarArticlesIncludeFromSimilarArticles'


class NewsArticleLabelsIncludeFromNewsArticles(TypedDict, total=False):
    """Relational arguments for NewsArticles"""
    article: Union[bool, 'NewsArticlesArgsFromNewsArticles']


class NewsArticleLabelsArgsFromNewsArticles(TypedDict, total=False):
    """Arguments for NewsArticles"""
    include: 'NewsArticleLabelsIncludeFromNewsArticleLabels'


class FindManyNewsArticleLabelsArgsFromNewsArticles(TypedDict, total=False):
    """Arguments for NewsArticles"""
    take: int
    skip: int
    order_by: Union['NewsArticleLabelsOrderByInput', List['NewsArticleLabelsOrderByInput']]
    where: 'NewsArticleLabelsWhereInput'
    cursor: 'NewsArticleLabelsWhereUniqueInput'
    distinct: List['NewsArticleLabelsScalarFieldKeys']
    include: 'NewsArticleLabelsIncludeFromNewsArticleLabels'


class UsersArticlesIncludeFromNewsArticles(TypedDict, total=False):
    """Relational arguments for NewsArticles"""
    article: Union[bool, 'NewsArticlesArgsFromNewsArticles']
    source: Union[bool, 'NewsSourcesArgsFromNewsArticles']
    user: Union[bool, 'UsersArgsFromNewsArticles']


class UsersArticlesArgsFromNewsArticles(TypedDict, total=False):
    """Arguments for NewsArticles"""
    include: 'UsersArticlesIncludeFromUsersArticles'


class FindManyUsersArticlesArgsFromNewsArticles(TypedDict, total=False):
    """Arguments for NewsArticles"""
    take: int
    skip: int
    order_by: Union['UsersArticlesOrderByInput', List['UsersArticlesOrderByInput']]
    where: 'UsersArticlesWhereInput'
    cursor: 'UsersArticlesWhereUniqueInput'
    distinct: List['UsersArticlesScalarFieldKeys']
    include: 'UsersArticlesIncludeFromUsersArticles'




FindManyNewsArticlesArgs = FindManyNewsArticlesArgsFromNewsArticles
FindFirstNewsArticlesArgs = FindManyNewsArticlesArgsFromNewsArticles


class NewsArticlesWhereInput(TypedDict, total=False):
    """NewsArticles arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    source: 'NewsSourcesRelationFilter'
    source_id: Union[_int, 'types.IntFilter']
    url: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    photo: Union[None, _str, 'types.StringFilter']
    publication_date: Union[None, datetime.datetime, 'types.DateTimeFilter']
    labels: 'NewsArticleLabelsListRelationFilter'
    similar_relation: 'SimilarArticlesListRelationFilter'
    similar_articles: 'SimilarArticlesListRelationFilter'
    UsersArticles: 'UsersArticlesRelationFilter'

    # should be noted that AND and NOT should be Union['NewsArticlesWhereInput', List['NewsArticlesWhereInput']]
    # but this causes mypy to hang :/
    AND: List['NewsArticlesWhereInput']
    OR: List['NewsArticlesWhereInput']
    NOT: List['NewsArticlesWhereInput']



# aggregate NewsArticles types


class NewsArticlesScalarWhereWithAggregatesInput(TypedDict, total=False):
    """NewsArticles arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    source_id: Union[_int, 'types.IntWithAggregatesFilter']
    url: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    photo: Union[_str, 'types.StringWithAggregatesFilter']
    publication_date: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['NewsArticlesScalarWhereWithAggregatesInput']
    OR: List['NewsArticlesScalarWhereWithAggregatesInput']
    NOT: List['NewsArticlesScalarWhereWithAggregatesInput']



class NewsArticlesGroupByOutput(TypedDict, total=False):
    id: _int
    source_id: _int
    url: _str
    title: _str
    description: _str
    photo: _str
    publication_date: datetime.datetime
    _sum: 'NewsArticlesSumAggregateOutput'
    _avg: 'NewsArticlesAvgAggregateOutput'
    _min: 'NewsArticlesMinAggregateOutput'
    _max: 'NewsArticlesMaxAggregateOutput'
    _count: 'NewsArticlesCountAggregateOutput'


class NewsArticlesAvgAggregateOutput(TypedDict, total=False):
    """NewsArticles output for aggregating averages"""
    id: float
    source_id: float


class NewsArticlesSumAggregateOutput(TypedDict, total=False):
    """NewsArticles output for aggregating sums"""
    id: _int
    source_id: _int


class NewsArticlesScalarAggregateOutput(TypedDict, total=False):
    """NewsArticles output including scalar fields"""
    id: _int
    source_id: _int
    url: _str
    title: _str
    description: _str
    photo: _str
    publication_date: datetime.datetime


NewsArticlesMinAggregateOutput = NewsArticlesScalarAggregateOutput
NewsArticlesMaxAggregateOutput = NewsArticlesScalarAggregateOutput


class NewsArticlesMaxAggregateInput(TypedDict, total=False):
    """NewsArticles input for aggregating by max"""
    id: bool
    source_id: bool
    url: bool
    title: bool
    description: bool
    photo: bool
    publication_date: bool


class NewsArticlesMinAggregateInput(TypedDict, total=False):
    """NewsArticles input for aggregating by min"""
    id: bool
    source_id: bool
    url: bool
    title: bool
    description: bool
    photo: bool
    publication_date: bool


class NewsArticlesNumberAggregateInput(TypedDict, total=False):
    """NewsArticles input for aggregating numbers"""
    id: bool
    source_id: bool


NewsArticlesAvgAggregateInput = NewsArticlesNumberAggregateInput
NewsArticlesSumAggregateInput = NewsArticlesNumberAggregateInput


NewsArticlesCountAggregateInput = TypedDict(
    'NewsArticlesCountAggregateInput',
    {
        'id': bool,
        'source_id': bool,
        'url': bool,
        'title': bool,
        'description': bool,
        'photo': bool,
        'publication_date': bool,
        '_all': bool,
    },
    total=False,
)

NewsArticlesCountAggregateOutput = TypedDict(
    'NewsArticlesCountAggregateOutput',
    {
        'id': int,
        'source_id': int,
        'url': int,
        'title': int,
        'description': int,
        'photo': int,
        'publication_date': int,
        '_all': int,
    },
    total=False,
)


NewsArticlesKeys = Literal[
    'id',
    'source',
    'source_id',
    'url',
    'title',
    'description',
    'photo',
    'publication_date',
    'labels',
    'similar_relation',
    'similar_articles',
    'UsersArticles',
]
NewsArticlesScalarFieldKeys = Literal[
    'id',
    'source_id',
    'url',
    'title',
    'description',
    'photo',
    'publication_date',
]
NewsArticlesScalarFieldKeysT = TypeVar('NewsArticlesScalarFieldKeysT', bound=NewsArticlesScalarFieldKeys)

NewsArticlesRelationalFieldKeys = Literal[
        'source',
        'labels',
        'similar_relation',
        'similar_articles',
        'UsersArticles',
    ]

# SimilarArticles types

class SimilarArticlesOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the SimilarArticles create method"""
    article: 'NewsArticlesCreateNestedWithoutRelationsInput'
    id1: _int
    similar: 'NewsArticlesCreateNestedWithoutRelationsInput'
    id2: _int


class SimilarArticlesCreateInput(SimilarArticlesOptionalCreateInput):
    """Required arguments to the SimilarArticles create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class SimilarArticlesOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the SimilarArticles create method, without relations"""
    id1: _int
    id2: _int


class SimilarArticlesCreateWithoutRelationsInput(SimilarArticlesOptionalCreateWithoutRelationsInput):
    """Required arguments to the SimilarArticles create method, without relations"""


class SimilarArticlesCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'SimilarArticlesCreateWithoutRelationsInput'
    connect: 'SimilarArticlesWhereUniqueInput'


class SimilarArticlesCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['SimilarArticlesCreateWithoutRelationsInput', List['SimilarArticlesCreateWithoutRelationsInput']]
    connect: Union['SimilarArticlesWhereUniqueInput', List['SimilarArticlesWhereUniqueInput']]


_SimilarArticlesCompoundPrimaryKeyInner = TypedDict(
    '_SimilarArticlesCompoundPrimaryKeyInner',
    {
        'id1': '_int',
        'id2': '_int',
    },
    total=True
)

_SimilarArticlesCompoundPrimaryKey = TypedDict(
    '_SimilarArticlesCompoundPrimaryKey',
    {
        'id1_id2': '_SimilarArticlesCompoundPrimaryKeyInner',
    },
    total=True
)

SimilarArticlesWhereUniqueInput = _SimilarArticlesCompoundPrimaryKey


class SimilarArticlesUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    article: 'NewsArticlesUpdateOneWithoutRelationsInput'
    similar: 'NewsArticlesUpdateOneWithoutRelationsInput'


class SimilarArticlesUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""


class SimilarArticlesUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['SimilarArticlesCreateWithoutRelationsInput']
    connect: List['SimilarArticlesWhereUniqueInput']
    set: List['SimilarArticlesWhereUniqueInput']
    disconnect: List['SimilarArticlesWhereUniqueInput']
    delete: List['SimilarArticlesWhereUniqueInput']

    # TODO
    # update: List['SimilarArticlesUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['SimilarArticlesUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['SimilarArticlesScalarWhereInput']
    # upsert: List['SimilarArticlesUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['SimilarArticlesCreateOrConnectWithoutRelationsInput']


class SimilarArticlesUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'SimilarArticlesCreateWithoutRelationsInput'
    connect: 'SimilarArticlesWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'SimilarArticlesUpdateInput'
    # upsert: 'SimilarArticlesUpsertWithoutRelationsInput'
    # connectOrCreate: 'SimilarArticlesCreateOrConnectWithoutRelationsInput'


class SimilarArticlesUpsertInput(TypedDict):
    create: 'SimilarArticlesCreateInput'
    update: 'SimilarArticlesUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_SimilarArticles_id1_OrderByInput = TypedDict(
    '_SimilarArticles_id1_OrderByInput',
    {
        'id1': 'SortOrder',
    },
    total=True
)

_SimilarArticles_id2_OrderByInput = TypedDict(
    '_SimilarArticles_id2_OrderByInput',
    {
        'id2': 'SortOrder',
    },
    total=True
)

SimilarArticlesOrderByInput = Union[
    '_SimilarArticles_id1_OrderByInput',
    '_SimilarArticles_id2_OrderByInput',
]



# recursive SimilarArticles types
# TODO: cleanup these types



SimilarArticlesRelationFilter = TypedDict(
    'SimilarArticlesRelationFilter',
    {
        'is': 'SimilarArticlesWhereInput',
        'is_not': 'SimilarArticlesWhereInput',
    },
    total=False,
)


class SimilarArticlesListRelationFilter(TypedDict, total=False):
    some: 'SimilarArticlesWhereInput'
    none: 'SimilarArticlesWhereInput'
    every: 'SimilarArticlesWhereInput'


class SimilarArticlesInclude(TypedDict, total=False):
    """SimilarArticles relational arguments"""
    article: Union[bool, 'NewsArticlesArgsFromSimilarArticles']
    similar: Union[bool, 'NewsArticlesArgsFromSimilarArticles']


class UsersIncludeFromSimilarArticles(TypedDict, total=False):
    """Relational arguments for SimilarArticles"""
    login: Union[bool, 'UserLoginsArgsFromSimilarArticles']
    cookies: Union[bool, 'FindManyUserCookiesArgsFromSimilarArticles']
    History: Union[bool, 'FindManyUsersArticlesArgsFromSimilarArticles']


class UsersArgsFromSimilarArticles(TypedDict, total=False):
    """Arguments for SimilarArticles"""
    include: 'UsersIncludeFromUsers'


class FindManyUsersArgsFromSimilarArticles(TypedDict, total=False):
    """Arguments for SimilarArticles"""
    take: int
    skip: int
    order_by: Union['UsersOrderByInput', List['UsersOrderByInput']]
    where: 'UsersWhereInput'
    cursor: 'UsersWhereUniqueInput'
    distinct: List['UsersScalarFieldKeys']
    include: 'UsersIncludeFromUsers'


class UserLoginsIncludeFromSimilarArticles(TypedDict, total=False):
    """Relational arguments for SimilarArticles"""
    user: Union[bool, 'UsersArgsFromSimilarArticles']


class UserLoginsArgsFromSimilarArticles(TypedDict, total=False):
    """Arguments for SimilarArticles"""
    include: 'UserLoginsIncludeFromUserLogins'


class FindManyUserLoginsArgsFromSimilarArticles(TypedDict, total=False):
    """Arguments for SimilarArticles"""
    take: int
    skip: int
    order_by: Union['UserLoginsOrderByInput', List['UserLoginsOrderByInput']]
    where: 'UserLoginsWhereInput'
    cursor: 'UserLoginsWhereUniqueInput'
    distinct: List['UserLoginsScalarFieldKeys']
    include: 'UserLoginsIncludeFromUserLogins'


class UserCookiesIncludeFromSimilarArticles(TypedDict, total=False):
    """Relational arguments for SimilarArticles"""
    user: Union[bool, 'UsersArgsFromSimilarArticles']


class UserCookiesArgsFromSimilarArticles(TypedDict, total=False):
    """Arguments for SimilarArticles"""
    include: 'UserCookiesIncludeFromUserCookies'


class FindManyUserCookiesArgsFromSimilarArticles(TypedDict, total=False):
    """Arguments for SimilarArticles"""
    take: int
    skip: int
    order_by: Union['UserCookiesOrderByInput', List['UserCookiesOrderByInput']]
    where: 'UserCookiesWhereInput'
    cursor: 'UserCookiesWhereUniqueInput'
    distinct: List['UserCookiesScalarFieldKeys']
    include: 'UserCookiesIncludeFromUserCookies'


class NewsSourcesIncludeFromSimilarArticles(TypedDict, total=False):
    """Relational arguments for SimilarArticles"""
    rss: Union[bool, 'FindManyRssEntriesArgsFromSimilarArticles']
    articles: Union[bool, 'FindManyNewsArticlesArgsFromSimilarArticles']
    UsersArticles: Union[bool, 'FindManyUsersArticlesArgsFromSimilarArticles']


class NewsSourcesArgsFromSimilarArticles(TypedDict, total=False):
    """Arguments for SimilarArticles"""
    include: 'NewsSourcesIncludeFromNewsSources'


class FindManyNewsSourcesArgsFromSimilarArticles(TypedDict, total=False):
    """Arguments for SimilarArticles"""
    take: int
    skip: int
    order_by: Union['NewsSourcesOrderByInput', List['NewsSourcesOrderByInput']]
    where: 'NewsSourcesWhereInput'
    cursor: 'NewsSourcesWhereUniqueInput'
    distinct: List['NewsSourcesScalarFieldKeys']
    include: 'NewsSourcesIncludeFromNewsSources'


class RssEntriesIncludeFromSimilarArticles(TypedDict, total=False):
    """Relational arguments for SimilarArticles"""
    source: Union[bool, 'NewsSourcesArgsFromSimilarArticles']


class RssEntriesArgsFromSimilarArticles(TypedDict, total=False):
    """Arguments for SimilarArticles"""
    include: 'RssEntriesIncludeFromRssEntries'


class FindManyRssEntriesArgsFromSimilarArticles(TypedDict, total=False):
    """Arguments for SimilarArticles"""
    take: int
    skip: int
    order_by: Union['RssEntriesOrderByInput', List['RssEntriesOrderByInput']]
    where: 'RssEntriesWhereInput'
    cursor: 'RssEntriesWhereUniqueInput'
    distinct: List['RssEntriesScalarFieldKeys']
    include: 'RssEntriesIncludeFromRssEntries'


class NewsArticlesIncludeFromSimilarArticles(TypedDict, total=False):
    """Relational arguments for SimilarArticles"""
    source: Union[bool, 'NewsSourcesArgsFromSimilarArticles']
    labels: Union[bool, 'FindManyNewsArticleLabelsArgsFromSimilarArticles']
    similar_relation: Union[bool, 'FindManySimilarArticlesArgsFromSimilarArticles']
    similar_articles: Union[bool, 'FindManySimilarArticlesArgsFromSimilarArticles']
    UsersArticles: Union[bool, 'UsersArticlesArgsFromSimilarArticles']


class NewsArticlesArgsFromSimilarArticles(TypedDict, total=False):
    """Arguments for SimilarArticles"""
    include: 'NewsArticlesIncludeFromNewsArticles'


class FindManyNewsArticlesArgsFromSimilarArticles(TypedDict, total=False):
    """Arguments for SimilarArticles"""
    take: int
    skip: int
    order_by: Union['NewsArticlesOrderByInput', List['NewsArticlesOrderByInput']]
    where: 'NewsArticlesWhereInput'
    cursor: 'NewsArticlesWhereUniqueInput'
    distinct: List['NewsArticlesScalarFieldKeys']
    include: 'NewsArticlesIncludeFromNewsArticles'


class SimilarArticlesIncludeFromSimilarArticles(TypedDict, total=False):
    """Relational arguments for SimilarArticles"""
    article: Union[bool, 'NewsArticlesArgsFromSimilarArticles']
    similar: Union[bool, 'NewsArticlesArgsFromSimilarArticles']


class SimilarArticlesArgsFromSimilarArticles(TypedDict, total=False):
    """Arguments for SimilarArticles"""
    include: 'SimilarArticlesIncludeFromSimilarArticles'


class FindManySimilarArticlesArgsFromSimilarArticles(TypedDict, total=False):
    """Arguments for SimilarArticles"""
    take: int
    skip: int
    order_by: Union['SimilarArticlesOrderByInput', List['SimilarArticlesOrderByInput']]
    where: 'SimilarArticlesWhereInput'
    cursor: 'SimilarArticlesWhereUniqueInput'
    distinct: List['SimilarArticlesScalarFieldKeys']
    include: 'SimilarArticlesIncludeFromSimilarArticles'


class NewsArticleLabelsIncludeFromSimilarArticles(TypedDict, total=False):
    """Relational arguments for SimilarArticles"""
    article: Union[bool, 'NewsArticlesArgsFromSimilarArticles']


class NewsArticleLabelsArgsFromSimilarArticles(TypedDict, total=False):
    """Arguments for SimilarArticles"""
    include: 'NewsArticleLabelsIncludeFromNewsArticleLabels'


class FindManyNewsArticleLabelsArgsFromSimilarArticles(TypedDict, total=False):
    """Arguments for SimilarArticles"""
    take: int
    skip: int
    order_by: Union['NewsArticleLabelsOrderByInput', List['NewsArticleLabelsOrderByInput']]
    where: 'NewsArticleLabelsWhereInput'
    cursor: 'NewsArticleLabelsWhereUniqueInput'
    distinct: List['NewsArticleLabelsScalarFieldKeys']
    include: 'NewsArticleLabelsIncludeFromNewsArticleLabels'


class UsersArticlesIncludeFromSimilarArticles(TypedDict, total=False):
    """Relational arguments for SimilarArticles"""
    article: Union[bool, 'NewsArticlesArgsFromSimilarArticles']
    source: Union[bool, 'NewsSourcesArgsFromSimilarArticles']
    user: Union[bool, 'UsersArgsFromSimilarArticles']


class UsersArticlesArgsFromSimilarArticles(TypedDict, total=False):
    """Arguments for SimilarArticles"""
    include: 'UsersArticlesIncludeFromUsersArticles'


class FindManyUsersArticlesArgsFromSimilarArticles(TypedDict, total=False):
    """Arguments for SimilarArticles"""
    take: int
    skip: int
    order_by: Union['UsersArticlesOrderByInput', List['UsersArticlesOrderByInput']]
    where: 'UsersArticlesWhereInput'
    cursor: 'UsersArticlesWhereUniqueInput'
    distinct: List['UsersArticlesScalarFieldKeys']
    include: 'UsersArticlesIncludeFromUsersArticles'




FindManySimilarArticlesArgs = FindManySimilarArticlesArgsFromSimilarArticles
FindFirstSimilarArticlesArgs = FindManySimilarArticlesArgsFromSimilarArticles


class SimilarArticlesWhereInput(TypedDict, total=False):
    """SimilarArticles arguments for searching"""
    article: 'NewsArticlesRelationFilter'
    id1: Union[_int, 'types.IntFilter']
    similar: 'NewsArticlesRelationFilter'
    id2: Union[_int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['SimilarArticlesWhereInput', List['SimilarArticlesWhereInput']]
    # but this causes mypy to hang :/
    AND: List['SimilarArticlesWhereInput']
    OR: List['SimilarArticlesWhereInput']
    NOT: List['SimilarArticlesWhereInput']



# aggregate SimilarArticles types


class SimilarArticlesScalarWhereWithAggregatesInput(TypedDict, total=False):
    """SimilarArticles arguments for searching"""
    id1: Union[_int, 'types.IntWithAggregatesFilter']
    id2: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['SimilarArticlesScalarWhereWithAggregatesInput']
    OR: List['SimilarArticlesScalarWhereWithAggregatesInput']
    NOT: List['SimilarArticlesScalarWhereWithAggregatesInput']



class SimilarArticlesGroupByOutput(TypedDict, total=False):
    id1: _int
    id2: _int
    _sum: 'SimilarArticlesSumAggregateOutput'
    _avg: 'SimilarArticlesAvgAggregateOutput'
    _min: 'SimilarArticlesMinAggregateOutput'
    _max: 'SimilarArticlesMaxAggregateOutput'
    _count: 'SimilarArticlesCountAggregateOutput'


class SimilarArticlesAvgAggregateOutput(TypedDict, total=False):
    """SimilarArticles output for aggregating averages"""
    id1: float
    id2: float


class SimilarArticlesSumAggregateOutput(TypedDict, total=False):
    """SimilarArticles output for aggregating sums"""
    id1: _int
    id2: _int


class SimilarArticlesScalarAggregateOutput(TypedDict, total=False):
    """SimilarArticles output including scalar fields"""
    id1: _int
    id2: _int


SimilarArticlesMinAggregateOutput = SimilarArticlesScalarAggregateOutput
SimilarArticlesMaxAggregateOutput = SimilarArticlesScalarAggregateOutput


class SimilarArticlesMaxAggregateInput(TypedDict, total=False):
    """SimilarArticles input for aggregating by max"""
    id1: bool
    id2: bool


class SimilarArticlesMinAggregateInput(TypedDict, total=False):
    """SimilarArticles input for aggregating by min"""
    id1: bool
    id2: bool


class SimilarArticlesNumberAggregateInput(TypedDict, total=False):
    """SimilarArticles input for aggregating numbers"""
    id1: bool
    id2: bool


SimilarArticlesAvgAggregateInput = SimilarArticlesNumberAggregateInput
SimilarArticlesSumAggregateInput = SimilarArticlesNumberAggregateInput


SimilarArticlesCountAggregateInput = TypedDict(
    'SimilarArticlesCountAggregateInput',
    {
        'id1': bool,
        'id2': bool,
        '_all': bool,
    },
    total=False,
)

SimilarArticlesCountAggregateOutput = TypedDict(
    'SimilarArticlesCountAggregateOutput',
    {
        'id1': int,
        'id2': int,
        '_all': int,
    },
    total=False,
)


SimilarArticlesKeys = Literal[
    'article',
    'id1',
    'similar',
    'id2',
]
SimilarArticlesScalarFieldKeys = Literal[
    'id1',
    'id2',
]
SimilarArticlesScalarFieldKeysT = TypeVar('SimilarArticlesScalarFieldKeysT', bound=SimilarArticlesScalarFieldKeys)

SimilarArticlesRelationalFieldKeys = Literal[
        'article',
        'similar',
    ]

# NewsArticleLabels types

class NewsArticleLabelsOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the NewsArticleLabels create method"""
    article: 'NewsArticlesCreateNestedWithoutRelationsInput'
    id: _int


class NewsArticleLabelsCreateInput(NewsArticleLabelsOptionalCreateInput):
    """Required arguments to the NewsArticleLabels create method"""
    label: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class NewsArticleLabelsOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the NewsArticleLabels create method, without relations"""
    id: _int


class NewsArticleLabelsCreateWithoutRelationsInput(NewsArticleLabelsOptionalCreateWithoutRelationsInput):
    """Required arguments to the NewsArticleLabels create method, without relations"""
    label: _str


class NewsArticleLabelsCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'NewsArticleLabelsCreateWithoutRelationsInput'
    connect: 'NewsArticleLabelsWhereUniqueInput'


class NewsArticleLabelsCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['NewsArticleLabelsCreateWithoutRelationsInput', List['NewsArticleLabelsCreateWithoutRelationsInput']]
    connect: Union['NewsArticleLabelsWhereUniqueInput', List['NewsArticleLabelsWhereUniqueInput']]


_NewsArticleLabelsCompoundPrimaryKeyInner = TypedDict(
    '_NewsArticleLabelsCompoundPrimaryKeyInner',
    {
        'id': '_int',
        'label': '_str',
    },
    total=True
)

_NewsArticleLabelsCompoundPrimaryKey = TypedDict(
    '_NewsArticleLabelsCompoundPrimaryKey',
    {
        'id_label': '_NewsArticleLabelsCompoundPrimaryKeyInner',
    },
    total=True
)

NewsArticleLabelsWhereUniqueInput = _NewsArticleLabelsCompoundPrimaryKey


class NewsArticleLabelsUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    article: 'NewsArticlesUpdateOneWithoutRelationsInput'
    label: _str


class NewsArticleLabelsUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    label: _str


class NewsArticleLabelsUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['NewsArticleLabelsCreateWithoutRelationsInput']
    connect: List['NewsArticleLabelsWhereUniqueInput']
    set: List['NewsArticleLabelsWhereUniqueInput']
    disconnect: List['NewsArticleLabelsWhereUniqueInput']
    delete: List['NewsArticleLabelsWhereUniqueInput']

    # TODO
    # update: List['NewsArticleLabelsUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['NewsArticleLabelsUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['NewsArticleLabelsScalarWhereInput']
    # upsert: List['NewsArticleLabelsUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['NewsArticleLabelsCreateOrConnectWithoutRelationsInput']


class NewsArticleLabelsUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'NewsArticleLabelsCreateWithoutRelationsInput'
    connect: 'NewsArticleLabelsWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'NewsArticleLabelsUpdateInput'
    # upsert: 'NewsArticleLabelsUpsertWithoutRelationsInput'
    # connectOrCreate: 'NewsArticleLabelsCreateOrConnectWithoutRelationsInput'


class NewsArticleLabelsUpsertInput(TypedDict):
    create: 'NewsArticleLabelsCreateInput'
    update: 'NewsArticleLabelsUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_NewsArticleLabels_id_OrderByInput = TypedDict(
    '_NewsArticleLabels_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_NewsArticleLabels_label_OrderByInput = TypedDict(
    '_NewsArticleLabels_label_OrderByInput',
    {
        'label': 'SortOrder',
    },
    total=True
)

NewsArticleLabelsOrderByInput = Union[
    '_NewsArticleLabels_id_OrderByInput',
    '_NewsArticleLabels_label_OrderByInput',
]



# recursive NewsArticleLabels types
# TODO: cleanup these types



NewsArticleLabelsRelationFilter = TypedDict(
    'NewsArticleLabelsRelationFilter',
    {
        'is': 'NewsArticleLabelsWhereInput',
        'is_not': 'NewsArticleLabelsWhereInput',
    },
    total=False,
)


class NewsArticleLabelsListRelationFilter(TypedDict, total=False):
    some: 'NewsArticleLabelsWhereInput'
    none: 'NewsArticleLabelsWhereInput'
    every: 'NewsArticleLabelsWhereInput'


class NewsArticleLabelsInclude(TypedDict, total=False):
    """NewsArticleLabels relational arguments"""
    article: Union[bool, 'NewsArticlesArgsFromNewsArticleLabels']


class UsersIncludeFromNewsArticleLabels(TypedDict, total=False):
    """Relational arguments for NewsArticleLabels"""
    login: Union[bool, 'UserLoginsArgsFromNewsArticleLabels']
    cookies: Union[bool, 'FindManyUserCookiesArgsFromNewsArticleLabels']
    History: Union[bool, 'FindManyUsersArticlesArgsFromNewsArticleLabels']


class UsersArgsFromNewsArticleLabels(TypedDict, total=False):
    """Arguments for NewsArticleLabels"""
    include: 'UsersIncludeFromUsers'


class FindManyUsersArgsFromNewsArticleLabels(TypedDict, total=False):
    """Arguments for NewsArticleLabels"""
    take: int
    skip: int
    order_by: Union['UsersOrderByInput', List['UsersOrderByInput']]
    where: 'UsersWhereInput'
    cursor: 'UsersWhereUniqueInput'
    distinct: List['UsersScalarFieldKeys']
    include: 'UsersIncludeFromUsers'


class UserLoginsIncludeFromNewsArticleLabels(TypedDict, total=False):
    """Relational arguments for NewsArticleLabels"""
    user: Union[bool, 'UsersArgsFromNewsArticleLabels']


class UserLoginsArgsFromNewsArticleLabels(TypedDict, total=False):
    """Arguments for NewsArticleLabels"""
    include: 'UserLoginsIncludeFromUserLogins'


class FindManyUserLoginsArgsFromNewsArticleLabels(TypedDict, total=False):
    """Arguments for NewsArticleLabels"""
    take: int
    skip: int
    order_by: Union['UserLoginsOrderByInput', List['UserLoginsOrderByInput']]
    where: 'UserLoginsWhereInput'
    cursor: 'UserLoginsWhereUniqueInput'
    distinct: List['UserLoginsScalarFieldKeys']
    include: 'UserLoginsIncludeFromUserLogins'


class UserCookiesIncludeFromNewsArticleLabels(TypedDict, total=False):
    """Relational arguments for NewsArticleLabels"""
    user: Union[bool, 'UsersArgsFromNewsArticleLabels']


class UserCookiesArgsFromNewsArticleLabels(TypedDict, total=False):
    """Arguments for NewsArticleLabels"""
    include: 'UserCookiesIncludeFromUserCookies'


class FindManyUserCookiesArgsFromNewsArticleLabels(TypedDict, total=False):
    """Arguments for NewsArticleLabels"""
    take: int
    skip: int
    order_by: Union['UserCookiesOrderByInput', List['UserCookiesOrderByInput']]
    where: 'UserCookiesWhereInput'
    cursor: 'UserCookiesWhereUniqueInput'
    distinct: List['UserCookiesScalarFieldKeys']
    include: 'UserCookiesIncludeFromUserCookies'


class NewsSourcesIncludeFromNewsArticleLabels(TypedDict, total=False):
    """Relational arguments for NewsArticleLabels"""
    rss: Union[bool, 'FindManyRssEntriesArgsFromNewsArticleLabels']
    articles: Union[bool, 'FindManyNewsArticlesArgsFromNewsArticleLabels']
    UsersArticles: Union[bool, 'FindManyUsersArticlesArgsFromNewsArticleLabels']


class NewsSourcesArgsFromNewsArticleLabels(TypedDict, total=False):
    """Arguments for NewsArticleLabels"""
    include: 'NewsSourcesIncludeFromNewsSources'


class FindManyNewsSourcesArgsFromNewsArticleLabels(TypedDict, total=False):
    """Arguments for NewsArticleLabels"""
    take: int
    skip: int
    order_by: Union['NewsSourcesOrderByInput', List['NewsSourcesOrderByInput']]
    where: 'NewsSourcesWhereInput'
    cursor: 'NewsSourcesWhereUniqueInput'
    distinct: List['NewsSourcesScalarFieldKeys']
    include: 'NewsSourcesIncludeFromNewsSources'


class RssEntriesIncludeFromNewsArticleLabels(TypedDict, total=False):
    """Relational arguments for NewsArticleLabels"""
    source: Union[bool, 'NewsSourcesArgsFromNewsArticleLabels']


class RssEntriesArgsFromNewsArticleLabels(TypedDict, total=False):
    """Arguments for NewsArticleLabels"""
    include: 'RssEntriesIncludeFromRssEntries'


class FindManyRssEntriesArgsFromNewsArticleLabels(TypedDict, total=False):
    """Arguments for NewsArticleLabels"""
    take: int
    skip: int
    order_by: Union['RssEntriesOrderByInput', List['RssEntriesOrderByInput']]
    where: 'RssEntriesWhereInput'
    cursor: 'RssEntriesWhereUniqueInput'
    distinct: List['RssEntriesScalarFieldKeys']
    include: 'RssEntriesIncludeFromRssEntries'


class NewsArticlesIncludeFromNewsArticleLabels(TypedDict, total=False):
    """Relational arguments for NewsArticleLabels"""
    source: Union[bool, 'NewsSourcesArgsFromNewsArticleLabels']
    labels: Union[bool, 'FindManyNewsArticleLabelsArgsFromNewsArticleLabels']
    similar_relation: Union[bool, 'FindManySimilarArticlesArgsFromNewsArticleLabels']
    similar_articles: Union[bool, 'FindManySimilarArticlesArgsFromNewsArticleLabels']
    UsersArticles: Union[bool, 'UsersArticlesArgsFromNewsArticleLabels']


class NewsArticlesArgsFromNewsArticleLabels(TypedDict, total=False):
    """Arguments for NewsArticleLabels"""
    include: 'NewsArticlesIncludeFromNewsArticles'


class FindManyNewsArticlesArgsFromNewsArticleLabels(TypedDict, total=False):
    """Arguments for NewsArticleLabels"""
    take: int
    skip: int
    order_by: Union['NewsArticlesOrderByInput', List['NewsArticlesOrderByInput']]
    where: 'NewsArticlesWhereInput'
    cursor: 'NewsArticlesWhereUniqueInput'
    distinct: List['NewsArticlesScalarFieldKeys']
    include: 'NewsArticlesIncludeFromNewsArticles'


class SimilarArticlesIncludeFromNewsArticleLabels(TypedDict, total=False):
    """Relational arguments for NewsArticleLabels"""
    article: Union[bool, 'NewsArticlesArgsFromNewsArticleLabels']
    similar: Union[bool, 'NewsArticlesArgsFromNewsArticleLabels']


class SimilarArticlesArgsFromNewsArticleLabels(TypedDict, total=False):
    """Arguments for NewsArticleLabels"""
    include: 'SimilarArticlesIncludeFromSimilarArticles'


class FindManySimilarArticlesArgsFromNewsArticleLabels(TypedDict, total=False):
    """Arguments for NewsArticleLabels"""
    take: int
    skip: int
    order_by: Union['SimilarArticlesOrderByInput', List['SimilarArticlesOrderByInput']]
    where: 'SimilarArticlesWhereInput'
    cursor: 'SimilarArticlesWhereUniqueInput'
    distinct: List['SimilarArticlesScalarFieldKeys']
    include: 'SimilarArticlesIncludeFromSimilarArticles'


class NewsArticleLabelsIncludeFromNewsArticleLabels(TypedDict, total=False):
    """Relational arguments for NewsArticleLabels"""
    article: Union[bool, 'NewsArticlesArgsFromNewsArticleLabels']


class NewsArticleLabelsArgsFromNewsArticleLabels(TypedDict, total=False):
    """Arguments for NewsArticleLabels"""
    include: 'NewsArticleLabelsIncludeFromNewsArticleLabels'


class FindManyNewsArticleLabelsArgsFromNewsArticleLabels(TypedDict, total=False):
    """Arguments for NewsArticleLabels"""
    take: int
    skip: int
    order_by: Union['NewsArticleLabelsOrderByInput', List['NewsArticleLabelsOrderByInput']]
    where: 'NewsArticleLabelsWhereInput'
    cursor: 'NewsArticleLabelsWhereUniqueInput'
    distinct: List['NewsArticleLabelsScalarFieldKeys']
    include: 'NewsArticleLabelsIncludeFromNewsArticleLabels'


class UsersArticlesIncludeFromNewsArticleLabels(TypedDict, total=False):
    """Relational arguments for NewsArticleLabels"""
    article: Union[bool, 'NewsArticlesArgsFromNewsArticleLabels']
    source: Union[bool, 'NewsSourcesArgsFromNewsArticleLabels']
    user: Union[bool, 'UsersArgsFromNewsArticleLabels']


class UsersArticlesArgsFromNewsArticleLabels(TypedDict, total=False):
    """Arguments for NewsArticleLabels"""
    include: 'UsersArticlesIncludeFromUsersArticles'


class FindManyUsersArticlesArgsFromNewsArticleLabels(TypedDict, total=False):
    """Arguments for NewsArticleLabels"""
    take: int
    skip: int
    order_by: Union['UsersArticlesOrderByInput', List['UsersArticlesOrderByInput']]
    where: 'UsersArticlesWhereInput'
    cursor: 'UsersArticlesWhereUniqueInput'
    distinct: List['UsersArticlesScalarFieldKeys']
    include: 'UsersArticlesIncludeFromUsersArticles'




FindManyNewsArticleLabelsArgs = FindManyNewsArticleLabelsArgsFromNewsArticleLabels
FindFirstNewsArticleLabelsArgs = FindManyNewsArticleLabelsArgsFromNewsArticleLabels


class NewsArticleLabelsWhereInput(TypedDict, total=False):
    """NewsArticleLabels arguments for searching"""
    article: 'NewsArticlesRelationFilter'
    id: Union[_int, 'types.IntFilter']
    label: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['NewsArticleLabelsWhereInput', List['NewsArticleLabelsWhereInput']]
    # but this causes mypy to hang :/
    AND: List['NewsArticleLabelsWhereInput']
    OR: List['NewsArticleLabelsWhereInput']
    NOT: List['NewsArticleLabelsWhereInput']



# aggregate NewsArticleLabels types


class NewsArticleLabelsScalarWhereWithAggregatesInput(TypedDict, total=False):
    """NewsArticleLabels arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    label: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['NewsArticleLabelsScalarWhereWithAggregatesInput']
    OR: List['NewsArticleLabelsScalarWhereWithAggregatesInput']
    NOT: List['NewsArticleLabelsScalarWhereWithAggregatesInput']



class NewsArticleLabelsGroupByOutput(TypedDict, total=False):
    id: _int
    label: _str
    _sum: 'NewsArticleLabelsSumAggregateOutput'
    _avg: 'NewsArticleLabelsAvgAggregateOutput'
    _min: 'NewsArticleLabelsMinAggregateOutput'
    _max: 'NewsArticleLabelsMaxAggregateOutput'
    _count: 'NewsArticleLabelsCountAggregateOutput'


class NewsArticleLabelsAvgAggregateOutput(TypedDict, total=False):
    """NewsArticleLabels output for aggregating averages"""
    id: float


class NewsArticleLabelsSumAggregateOutput(TypedDict, total=False):
    """NewsArticleLabels output for aggregating sums"""
    id: _int


class NewsArticleLabelsScalarAggregateOutput(TypedDict, total=False):
    """NewsArticleLabels output including scalar fields"""
    id: _int
    label: _str


NewsArticleLabelsMinAggregateOutput = NewsArticleLabelsScalarAggregateOutput
NewsArticleLabelsMaxAggregateOutput = NewsArticleLabelsScalarAggregateOutput


class NewsArticleLabelsMaxAggregateInput(TypedDict, total=False):
    """NewsArticleLabels input for aggregating by max"""
    id: bool
    label: bool


class NewsArticleLabelsMinAggregateInput(TypedDict, total=False):
    """NewsArticleLabels input for aggregating by min"""
    id: bool
    label: bool


class NewsArticleLabelsNumberAggregateInput(TypedDict, total=False):
    """NewsArticleLabels input for aggregating numbers"""
    id: bool


NewsArticleLabelsAvgAggregateInput = NewsArticleLabelsNumberAggregateInput
NewsArticleLabelsSumAggregateInput = NewsArticleLabelsNumberAggregateInput


NewsArticleLabelsCountAggregateInput = TypedDict(
    'NewsArticleLabelsCountAggregateInput',
    {
        'id': bool,
        'label': bool,
        '_all': bool,
    },
    total=False,
)

NewsArticleLabelsCountAggregateOutput = TypedDict(
    'NewsArticleLabelsCountAggregateOutput',
    {
        'id': int,
        'label': int,
        '_all': int,
    },
    total=False,
)


NewsArticleLabelsKeys = Literal[
    'article',
    'id',
    'label',
]
NewsArticleLabelsScalarFieldKeys = Literal[
    'id',
    'label',
]
NewsArticleLabelsScalarFieldKeysT = TypeVar('NewsArticleLabelsScalarFieldKeysT', bound=NewsArticleLabelsScalarFieldKeys)

NewsArticleLabelsRelationalFieldKeys = Literal[
        'article',
    ]

# UsersArticles types

class UsersArticlesOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the UsersArticles create method"""
    article: 'NewsArticlesCreateNestedWithoutRelationsInput'
    article_id: _int
    source: 'NewsSourcesCreateNestedWithoutRelationsInput'
    source_id: _int
    url: _str
    user: 'UsersCreateNestedWithoutRelationsInput'
    user_id: _int


class UsersArticlesCreateInput(UsersArticlesOptionalCreateInput):
    """Required arguments to the UsersArticles create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UsersArticlesOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the UsersArticles create method, without relations"""
    article_id: _int
    source_id: _int
    url: _str
    user_id: _int


class UsersArticlesCreateWithoutRelationsInput(UsersArticlesOptionalCreateWithoutRelationsInput):
    """Required arguments to the UsersArticles create method, without relations"""


class UsersArticlesCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UsersArticlesCreateWithoutRelationsInput'
    connect: 'UsersArticlesWhereUniqueInput'


class UsersArticlesCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UsersArticlesCreateWithoutRelationsInput', List['UsersArticlesCreateWithoutRelationsInput']]
    connect: Union['UsersArticlesWhereUniqueInput', List['UsersArticlesWhereUniqueInput']]


_UsersArticlesCompoundPrimaryKeyInner = TypedDict(
    '_UsersArticlesCompoundPrimaryKeyInner',
    {
        'user_id': '_int',
        'article_id': '_int',
    },
    total=True
)

_UsersArticlesCompoundPrimaryKey = TypedDict(
    '_UsersArticlesCompoundPrimaryKey',
    {
        'user_id_article_id': '_UsersArticlesCompoundPrimaryKeyInner',
    },
    total=True
)

_UsersArticlesCompoundarticle_id_urlKeyInner = TypedDict(
    '_UsersArticlesCompoundarticle_id_urlKeyInner',
    {
        'article_id': '_int',
        'url': '_str',
    },
    total=True
)

_UsersArticlesCompoundarticle_id_urlKey = TypedDict(
    '_UsersArticlesCompoundarticle_id_urlKey',
    {
        'article_id_url': '_UsersArticlesCompoundarticle_id_urlKeyInner',
    },
    total=True
)

UsersArticlesWhereUniqueInput = Union[
    '_UsersArticlesCompoundPrimaryKey',
    '_UsersArticlesCompoundarticle_id_urlKey',
]


class UsersArticlesUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    article: 'NewsArticlesUpdateOneWithoutRelationsInput'
    source: 'NewsSourcesUpdateOneWithoutRelationsInput'
    user: 'UsersUpdateOneWithoutRelationsInput'


class UsersArticlesUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""


class UsersArticlesUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UsersArticlesCreateWithoutRelationsInput']
    connect: List['UsersArticlesWhereUniqueInput']
    set: List['UsersArticlesWhereUniqueInput']
    disconnect: List['UsersArticlesWhereUniqueInput']
    delete: List['UsersArticlesWhereUniqueInput']

    # TODO
    # update: List['UsersArticlesUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UsersArticlesUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UsersArticlesScalarWhereInput']
    # upsert: List['UsersArticlesUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['UsersArticlesCreateOrConnectWithoutRelationsInput']


class UsersArticlesUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UsersArticlesCreateWithoutRelationsInput'
    connect: 'UsersArticlesWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UsersArticlesUpdateInput'
    # upsert: 'UsersArticlesUpsertWithoutRelationsInput'
    # connectOrCreate: 'UsersArticlesCreateOrConnectWithoutRelationsInput'


class UsersArticlesUpsertInput(TypedDict):
    create: 'UsersArticlesCreateInput'
    update: 'UsersArticlesUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_UsersArticles_article_id_OrderByInput = TypedDict(
    '_UsersArticles_article_id_OrderByInput',
    {
        'article_id': 'SortOrder',
    },
    total=True
)

_UsersArticles_source_id_OrderByInput = TypedDict(
    '_UsersArticles_source_id_OrderByInput',
    {
        'source_id': 'SortOrder',
    },
    total=True
)

_UsersArticles_url_OrderByInput = TypedDict(
    '_UsersArticles_url_OrderByInput',
    {
        'url': 'SortOrder',
    },
    total=True
)

_UsersArticles_user_id_OrderByInput = TypedDict(
    '_UsersArticles_user_id_OrderByInput',
    {
        'user_id': 'SortOrder',
    },
    total=True
)

UsersArticlesOrderByInput = Union[
    '_UsersArticles_article_id_OrderByInput',
    '_UsersArticles_source_id_OrderByInput',
    '_UsersArticles_url_OrderByInput',
    '_UsersArticles_user_id_OrderByInput',
]



# recursive UsersArticles types
# TODO: cleanup these types



UsersArticlesRelationFilter = TypedDict(
    'UsersArticlesRelationFilter',
    {
        'is': 'UsersArticlesWhereInput',
        'is_not': 'UsersArticlesWhereInput',
    },
    total=False,
)


class UsersArticlesListRelationFilter(TypedDict, total=False):
    some: 'UsersArticlesWhereInput'
    none: 'UsersArticlesWhereInput'
    every: 'UsersArticlesWhereInput'


class UsersArticlesInclude(TypedDict, total=False):
    """UsersArticles relational arguments"""
    article: Union[bool, 'NewsArticlesArgsFromUsersArticles']
    source: Union[bool, 'NewsSourcesArgsFromUsersArticles']
    user: Union[bool, 'UsersArgsFromUsersArticles']


class UsersIncludeFromUsersArticles(TypedDict, total=False):
    """Relational arguments for UsersArticles"""
    login: Union[bool, 'UserLoginsArgsFromUsersArticles']
    cookies: Union[bool, 'FindManyUserCookiesArgsFromUsersArticles']
    History: Union[bool, 'FindManyUsersArticlesArgsFromUsersArticles']


class UsersArgsFromUsersArticles(TypedDict, total=False):
    """Arguments for UsersArticles"""
    include: 'UsersIncludeFromUsers'


class FindManyUsersArgsFromUsersArticles(TypedDict, total=False):
    """Arguments for UsersArticles"""
    take: int
    skip: int
    order_by: Union['UsersOrderByInput', List['UsersOrderByInput']]
    where: 'UsersWhereInput'
    cursor: 'UsersWhereUniqueInput'
    distinct: List['UsersScalarFieldKeys']
    include: 'UsersIncludeFromUsers'


class UserLoginsIncludeFromUsersArticles(TypedDict, total=False):
    """Relational arguments for UsersArticles"""
    user: Union[bool, 'UsersArgsFromUsersArticles']


class UserLoginsArgsFromUsersArticles(TypedDict, total=False):
    """Arguments for UsersArticles"""
    include: 'UserLoginsIncludeFromUserLogins'


class FindManyUserLoginsArgsFromUsersArticles(TypedDict, total=False):
    """Arguments for UsersArticles"""
    take: int
    skip: int
    order_by: Union['UserLoginsOrderByInput', List['UserLoginsOrderByInput']]
    where: 'UserLoginsWhereInput'
    cursor: 'UserLoginsWhereUniqueInput'
    distinct: List['UserLoginsScalarFieldKeys']
    include: 'UserLoginsIncludeFromUserLogins'


class UserCookiesIncludeFromUsersArticles(TypedDict, total=False):
    """Relational arguments for UsersArticles"""
    user: Union[bool, 'UsersArgsFromUsersArticles']


class UserCookiesArgsFromUsersArticles(TypedDict, total=False):
    """Arguments for UsersArticles"""
    include: 'UserCookiesIncludeFromUserCookies'


class FindManyUserCookiesArgsFromUsersArticles(TypedDict, total=False):
    """Arguments for UsersArticles"""
    take: int
    skip: int
    order_by: Union['UserCookiesOrderByInput', List['UserCookiesOrderByInput']]
    where: 'UserCookiesWhereInput'
    cursor: 'UserCookiesWhereUniqueInput'
    distinct: List['UserCookiesScalarFieldKeys']
    include: 'UserCookiesIncludeFromUserCookies'


class NewsSourcesIncludeFromUsersArticles(TypedDict, total=False):
    """Relational arguments for UsersArticles"""
    rss: Union[bool, 'FindManyRssEntriesArgsFromUsersArticles']
    articles: Union[bool, 'FindManyNewsArticlesArgsFromUsersArticles']
    UsersArticles: Union[bool, 'FindManyUsersArticlesArgsFromUsersArticles']


class NewsSourcesArgsFromUsersArticles(TypedDict, total=False):
    """Arguments for UsersArticles"""
    include: 'NewsSourcesIncludeFromNewsSources'


class FindManyNewsSourcesArgsFromUsersArticles(TypedDict, total=False):
    """Arguments for UsersArticles"""
    take: int
    skip: int
    order_by: Union['NewsSourcesOrderByInput', List['NewsSourcesOrderByInput']]
    where: 'NewsSourcesWhereInput'
    cursor: 'NewsSourcesWhereUniqueInput'
    distinct: List['NewsSourcesScalarFieldKeys']
    include: 'NewsSourcesIncludeFromNewsSources'


class RssEntriesIncludeFromUsersArticles(TypedDict, total=False):
    """Relational arguments for UsersArticles"""
    source: Union[bool, 'NewsSourcesArgsFromUsersArticles']


class RssEntriesArgsFromUsersArticles(TypedDict, total=False):
    """Arguments for UsersArticles"""
    include: 'RssEntriesIncludeFromRssEntries'


class FindManyRssEntriesArgsFromUsersArticles(TypedDict, total=False):
    """Arguments for UsersArticles"""
    take: int
    skip: int
    order_by: Union['RssEntriesOrderByInput', List['RssEntriesOrderByInput']]
    where: 'RssEntriesWhereInput'
    cursor: 'RssEntriesWhereUniqueInput'
    distinct: List['RssEntriesScalarFieldKeys']
    include: 'RssEntriesIncludeFromRssEntries'


class NewsArticlesIncludeFromUsersArticles(TypedDict, total=False):
    """Relational arguments for UsersArticles"""
    source: Union[bool, 'NewsSourcesArgsFromUsersArticles']
    labels: Union[bool, 'FindManyNewsArticleLabelsArgsFromUsersArticles']
    similar_relation: Union[bool, 'FindManySimilarArticlesArgsFromUsersArticles']
    similar_articles: Union[bool, 'FindManySimilarArticlesArgsFromUsersArticles']
    UsersArticles: Union[bool, 'UsersArticlesArgsFromUsersArticles']


class NewsArticlesArgsFromUsersArticles(TypedDict, total=False):
    """Arguments for UsersArticles"""
    include: 'NewsArticlesIncludeFromNewsArticles'


class FindManyNewsArticlesArgsFromUsersArticles(TypedDict, total=False):
    """Arguments for UsersArticles"""
    take: int
    skip: int
    order_by: Union['NewsArticlesOrderByInput', List['NewsArticlesOrderByInput']]
    where: 'NewsArticlesWhereInput'
    cursor: 'NewsArticlesWhereUniqueInput'
    distinct: List['NewsArticlesScalarFieldKeys']
    include: 'NewsArticlesIncludeFromNewsArticles'


class SimilarArticlesIncludeFromUsersArticles(TypedDict, total=False):
    """Relational arguments for UsersArticles"""
    article: Union[bool, 'NewsArticlesArgsFromUsersArticles']
    similar: Union[bool, 'NewsArticlesArgsFromUsersArticles']


class SimilarArticlesArgsFromUsersArticles(TypedDict, total=False):
    """Arguments for UsersArticles"""
    include: 'SimilarArticlesIncludeFromSimilarArticles'


class FindManySimilarArticlesArgsFromUsersArticles(TypedDict, total=False):
    """Arguments for UsersArticles"""
    take: int
    skip: int
    order_by: Union['SimilarArticlesOrderByInput', List['SimilarArticlesOrderByInput']]
    where: 'SimilarArticlesWhereInput'
    cursor: 'SimilarArticlesWhereUniqueInput'
    distinct: List['SimilarArticlesScalarFieldKeys']
    include: 'SimilarArticlesIncludeFromSimilarArticles'


class NewsArticleLabelsIncludeFromUsersArticles(TypedDict, total=False):
    """Relational arguments for UsersArticles"""
    article: Union[bool, 'NewsArticlesArgsFromUsersArticles']


class NewsArticleLabelsArgsFromUsersArticles(TypedDict, total=False):
    """Arguments for UsersArticles"""
    include: 'NewsArticleLabelsIncludeFromNewsArticleLabels'


class FindManyNewsArticleLabelsArgsFromUsersArticles(TypedDict, total=False):
    """Arguments for UsersArticles"""
    take: int
    skip: int
    order_by: Union['NewsArticleLabelsOrderByInput', List['NewsArticleLabelsOrderByInput']]
    where: 'NewsArticleLabelsWhereInput'
    cursor: 'NewsArticleLabelsWhereUniqueInput'
    distinct: List['NewsArticleLabelsScalarFieldKeys']
    include: 'NewsArticleLabelsIncludeFromNewsArticleLabels'


class UsersArticlesIncludeFromUsersArticles(TypedDict, total=False):
    """Relational arguments for UsersArticles"""
    article: Union[bool, 'NewsArticlesArgsFromUsersArticles']
    source: Union[bool, 'NewsSourcesArgsFromUsersArticles']
    user: Union[bool, 'UsersArgsFromUsersArticles']


class UsersArticlesArgsFromUsersArticles(TypedDict, total=False):
    """Arguments for UsersArticles"""
    include: 'UsersArticlesIncludeFromUsersArticles'


class FindManyUsersArticlesArgsFromUsersArticles(TypedDict, total=False):
    """Arguments for UsersArticles"""
    take: int
    skip: int
    order_by: Union['UsersArticlesOrderByInput', List['UsersArticlesOrderByInput']]
    where: 'UsersArticlesWhereInput'
    cursor: 'UsersArticlesWhereUniqueInput'
    distinct: List['UsersArticlesScalarFieldKeys']
    include: 'UsersArticlesIncludeFromUsersArticles'




FindManyUsersArticlesArgs = FindManyUsersArticlesArgsFromUsersArticles
FindFirstUsersArticlesArgs = FindManyUsersArticlesArgsFromUsersArticles


class UsersArticlesWhereInput(TypedDict, total=False):
    """UsersArticles arguments for searching"""
    article: 'NewsArticlesRelationFilter'
    article_id: Union[_int, 'types.IntFilter']
    source: 'NewsSourcesRelationFilter'
    source_id: Union[_int, 'types.IntFilter']
    url: Union[_str, 'types.StringFilter']
    user: 'UsersRelationFilter'
    user_id: Union[_int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['UsersArticlesWhereInput', List['UsersArticlesWhereInput']]
    # but this causes mypy to hang :/
    AND: List['UsersArticlesWhereInput']
    OR: List['UsersArticlesWhereInput']
    NOT: List['UsersArticlesWhereInput']



# aggregate UsersArticles types


class UsersArticlesScalarWhereWithAggregatesInput(TypedDict, total=False):
    """UsersArticles arguments for searching"""
    article_id: Union[_int, 'types.IntWithAggregatesFilter']
    source_id: Union[_int, 'types.IntWithAggregatesFilter']
    url: Union[_str, 'types.StringWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['UsersArticlesScalarWhereWithAggregatesInput']
    OR: List['UsersArticlesScalarWhereWithAggregatesInput']
    NOT: List['UsersArticlesScalarWhereWithAggregatesInput']



class UsersArticlesGroupByOutput(TypedDict, total=False):
    article_id: _int
    source_id: _int
    url: _str
    user_id: _int
    _sum: 'UsersArticlesSumAggregateOutput'
    _avg: 'UsersArticlesAvgAggregateOutput'
    _min: 'UsersArticlesMinAggregateOutput'
    _max: 'UsersArticlesMaxAggregateOutput'
    _count: 'UsersArticlesCountAggregateOutput'


class UsersArticlesAvgAggregateOutput(TypedDict, total=False):
    """UsersArticles output for aggregating averages"""
    article_id: float
    source_id: float
    user_id: float


class UsersArticlesSumAggregateOutput(TypedDict, total=False):
    """UsersArticles output for aggregating sums"""
    article_id: _int
    source_id: _int
    user_id: _int


class UsersArticlesScalarAggregateOutput(TypedDict, total=False):
    """UsersArticles output including scalar fields"""
    article_id: _int
    source_id: _int
    url: _str
    user_id: _int


UsersArticlesMinAggregateOutput = UsersArticlesScalarAggregateOutput
UsersArticlesMaxAggregateOutput = UsersArticlesScalarAggregateOutput


class UsersArticlesMaxAggregateInput(TypedDict, total=False):
    """UsersArticles input for aggregating by max"""
    article_id: bool
    source_id: bool
    url: bool
    user_id: bool


class UsersArticlesMinAggregateInput(TypedDict, total=False):
    """UsersArticles input for aggregating by min"""
    article_id: bool
    source_id: bool
    url: bool
    user_id: bool


class UsersArticlesNumberAggregateInput(TypedDict, total=False):
    """UsersArticles input for aggregating numbers"""
    article_id: bool
    source_id: bool
    user_id: bool


UsersArticlesAvgAggregateInput = UsersArticlesNumberAggregateInput
UsersArticlesSumAggregateInput = UsersArticlesNumberAggregateInput


UsersArticlesCountAggregateInput = TypedDict(
    'UsersArticlesCountAggregateInput',
    {
        'article_id': bool,
        'source_id': bool,
        'url': bool,
        'user_id': bool,
        '_all': bool,
    },
    total=False,
)

UsersArticlesCountAggregateOutput = TypedDict(
    'UsersArticlesCountAggregateOutput',
    {
        'article_id': int,
        'source_id': int,
        'url': int,
        'user_id': int,
        '_all': int,
    },
    total=False,
)


UsersArticlesKeys = Literal[
    'article',
    'article_id',
    'source',
    'source_id',
    'url',
    'user',
    'user_id',
]
UsersArticlesScalarFieldKeys = Literal[
    'article_id',
    'source_id',
    'url',
    'user_id',
]
UsersArticlesScalarFieldKeysT = TypeVar('UsersArticlesScalarFieldKeysT', bound=UsersArticlesScalarFieldKeys)

UsersArticlesRelationalFieldKeys = Literal[
        'article',
        'source',
        'user',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields